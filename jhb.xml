<prompt>

<goal>
We are working on a Node.js program to take advantage of arbitrage opportunities between cryptocurrency exchanges. The program relies on CCXT to interface with most exchanges, and we need to integrate support for two custom exchanges.
</goal>

<context>
1. Our codebase uses CCXT extensively, and all integrations must align with its architecture and design principles.
2. We have already implemented some parts of the program, which are shared below for your reference.
3. Your task is to expand the functionality by defining these two custom exchanges using CCXT's extensibility features.
</context>

<codebase>
Directory Structure:
-------------------
/ 
├── close/
│   └── closePosition.js
├── fetch/
│   ├── fetchOrderBooks.js
│   └── fetchPrices.js
├── monitoring/
│   └── monitoring.js
├── opportunitiesAndFinalReturns/
│   └── opportunitiesAndFinalReturns.js
├── orderCreation/
│   ├── orderCreation.js
│   └── orderExchangeCreation.js
├── precisions/
│   └── precisions.js
├── transforms/
│   ├── originalizations.js
│   └── standardizations.js
├── utils/
│   ├── addTMNSymbols.js
│   ├── calculateTMNPrice.js
│   ├── database.js
│   ├── splitSymbols.js
│   └── storeOpenPositions.js
├── VWAP/
│   └── VWAP.js
├── .gitignore
├── .prettierrc
├── config.js
├── dump.py
├── exclude.txt
├── index.js
├── open_positions.db
├── output.txt
├── package.json
└── test.js

File Contents:
--------------
File: ./test.js
--------------------------------------------------
Content of ./test.js:
import dotenv from 'dotenv';
import path from 'path';
import { fileURLToPath } from 'url';

dotenv.config({ path: import.meta.dirname + './.env' });

console.log(process.env.SECRET_KEY);
const __filename = fileURLToPath(import.meta.url);
console.log(path.dirname(__filename));
console.log(import.meta);


File: ./index.js
--------------------------------------------------
Content of ./index.js:
// Import required libraries

import ccxt from 'ccxt';
import { standardizeSpecialCoinPrices } from './transforms/standardizations.js';
import { fetchAllPrices } from './fetch/fetchPrices.js';
import {
  calculateFinalReturns,
  findArbitrageOpportunities,
} from './opportunitiesAndFinalReturns/opportunitiesAndFinalReturns.js';
import { calculateTMNPrice } from './utils/calculateTMNPrice.js';
import { CONFIG } from './config.js';
import { createOrder } from './orderCreation/orderCreation.js';
import { monitorOpenPositions } from './monitoring/monitoring.js';
import dotenv from 'dotenv';

dotenv.config({ path: './.env' });

const {
  exchangesToUse,
  exchangeParams,
  customExchanges,
  minMarginPercent,
  returnTypeOnOpen,
  orderTypeOnOpen,
  refreshIntervalMs,
  testMode = true,
} = CONFIG;
// Initialize exchanges
const exchanges = {};

// Initialize ccxt exchanges
for (const id of exchangesToUse) {
  if (ccxt.exchanges.includes(id) && !customExchanges.includes(id)) {
    exchanges[id] = new ccxt[id]({
      apiKey: exchangeParams[id]?.apiKey,
      secret: exchangeParams[id]?.secret,
      options: exchangeParams[id]?.options,
      enableRateLimit: true,
    });
    if (testMode) {
      exchanges[id].setSandboxMode(true);
    }
  } else if (!customExchanges.includes(id)) {
    throw new Error(`Unsupported exchange: ${id}`);
  }
}

// Main Execution Function

while (true) {
  try {
    const allPrices = await fetchAllPrices(exchanges);

    console.log('COMPLETE: Price fetching\n');

    const nobitexUSDTPrice =
      (allPrices.nobitex['USDT/TMN'].ask + allPrices.nobitex['USDT/TMN'].bid) /
      2;
    /* const wallexUSDTPrice =
        (allPrices.wallex['USDT/TMN'].ask + allPrices.wallex['USDT/TMN'].bid) /
        2; 
      const USDTPrice = Math.floor((nobitexUSDTPrice + wallexUSDTPrice) / 2);*/
    const USDTPrice = Math.floor(nobitexUSDTPrice);

    standardizeSpecialCoinPrices(allPrices);
    calculateTMNPrice(allPrices, USDTPrice);

    const opportunities = findArbitrageOpportunities(allPrices);

    let finalReturns = await calculateFinalReturns(
      opportunities,
      exchanges,
      USDTPrice,
      returnTypeOnOpen,
    );

    finalReturns = finalReturns
      .filter(
        fr =>
          fr.selectedReturnPercentage > minMarginPercent - 1 &&
          fr.selectedReturnPercentage < 4,
      )
      .sort((a, b) => b.selectedReturnPercentage - a.selectedReturnPercentage);

    if (finalReturns?.length) {
      const order = finalReturns[0];

      await createOrder(exchanges, order, orderTypeOnOpen);
    }

    if (!finalReturns?.length) {
      console.log('No profitable position available!');
    }

    for (const finalReturn of finalReturns?.slice(0, 3)) {
      console.log(
        `Position: Long ${finalReturn.symbol} on ${
          finalReturn.buyExchange
        } at ${finalReturn.selectedBuyPrice.toFixed(6)}, Short on ${
          finalReturn.sellExchange
        } at ${finalReturn.selectedSellPrice.toFixed(
          6,
        )}, Expected Return: ${finalReturn.selectedReturnPercentage.toFixed(
          2,
        )}%`,
      );
    }

    // Monitor open positions
    await monitorOpenPositions(exchanges, USDTPrice);
    console.log('-----------------------------\n\n');

    // Wait before next iteration
    await new Promise(resolve => setTimeout(resolve, refreshIntervalMs));
  } catch (error) {
    console.error('An error occurred:', error.message);
    // Wait before next iteration in case of error
    await new Promise(resolve => setTimeout(resolve, refreshIntervalMs));
  }
}


File: ./config.js
--------------------------------------------------
Content of ./config.js:
import 'dotenv/config';
// Configuration
export const CONFIG = {
  testMode: true,
  minMarginPercent: -0.2, // Minimum margin percentage to consider
  minVolumeUSD: 10, // Minimum trade volume in USDT
  returnTypeOnOpen: 'spread', // enum: [null, 'slip', 'spread']
  returnTypeOnClose: null, // enum: [null, 'slip']
  closeMinMarginPercent: 0.4,
  orderTypeOnOpen: 'limit',
  orderTypeOnClose: 'limit',
  leverage: 1, // Leverage for positions
  refreshIntervalMs: 10000, // Interval to refresh data in milliseconds
  fees: {
    coinex: { maker: 0.0015, taker: 0.0015 },
    nobitex: { maker: 0.0015, taker: 0.0015 },
    wallex: { maker: 0.001, taker: 0.001 },
  },
  slippage: 0.0005,
  exchangesToUse: ['nobitex', 'wallex'],
  customExchanges: ['nobitex', 'wallex'],
  coinsToConsider: null, // null means all coins
  coinsToIgnore: ['OMG', 'X', 'BCH'],
  specialCoinStandardizations: {
    nobitex: [
      {
        originalBase: '100K_FLOKI',
        standardBase: 'FLOKI',
        correctionFactor: 1e-5,
      },
      {
        originalBase: '1B_BABYDOGE',
        standardBase: 'BABYDOGE',
        correctionFactor: 1e-9,
      },
      {
        originalBase: '1M_BTT',
        standardBase: 'BTT',
        correctionFactor: 1e-6,
      },
      {
        originalBase: '1M_NFT',
        standardBase: 'NFT',
        correctionFactor: 1e-6,
      },
      {
        originalBase: '1M_PEPE',
        standardBase: 'PEPE',
        correctionFactor: 1e-6,
      },
      {
        originalBase: 'SHIB',
        standardBase: 'SHIB',
        correctionFactor: 1e-3,
      },
    ],
    wallex: [
      {
        originalBase: '1BBABYDOGE',
        standardBase: 'BABYDOGE',
        correctionFactor: 1e-9,
      },
    ],
  },
  exchangeParams: {
    coinex: {
      apiKey: process.env.COINEX_API_KEY,
      secret: process.env.COINEX_SECRET_KEY,
      options: {
        defaultType: 'future',
      },
    },
    nobitex: {
      apiKey: process.env.NOBITEX_API_KEY,
      secret: process.env.NOBITEX_SECRET_KEY,
    },
    wallex: {
      apiKey: process.env.WALLEX_API_KEY,
      secret: process.env.WALLEX_SECRET_KEY,
    },
  },
  databaseName: './open_positions.db',
};


File: opportunitiesAndFinalReturns/opportunitiesAndFinalReturns.js
--------------------------------------------------
Content of opportunitiesAndFinalReturns/opportunitiesAndFinalReturns.js:
import NodeCache from 'node-cache';
import { CONFIG } from '../config.js';
import { getVWAPs } from '../VWAP/VWAP.js';
import { addTMNSymbols } from '../utils/addTMNSymbols.js';

const cache = new NodeCache({ stdTTL: 600 });

export function findArbitrageOpportunities(allPrices) {
  const { minMarginPercent, fees } = CONFIG;

  const opportunities = new Array(1000); // Preallocate space for opportunities
  let opportunityCount = 0;

  const exchanges = Object.keys(allPrices);
  const exchangeCount = exchanges.length;

  const feeMultipliers = new Map(
    exchanges.map(exchange => [
      exchange,
      {
        buy: 1 + fees[exchange].taker,
        sell: 1 - fees[exchange].taker,
      },
    ]),
  );

  for (let i = 0; i < exchangeCount - 1; i++) {
    const exchangeA = exchanges[i];
    const dataA = allPrices[exchangeA];

    for (let j = i + 1; j < exchangeCount; j++) {
      const exchangeB = exchanges[j];
      const dataB = allPrices[exchangeB];

      // Generate a unique cache key
      const cacheKey = `${exchangeA}-${exchangeB}`;

      // Retrieve or compute common bases
      let commonSymbols = cache.get(cacheKey);
      if (!commonSymbols) {
        const symbolA = new Set(Object.keys(dataA));
        const symbolB = new Set(Object.keys(dataB));
        commonSymbols = [...symbolA].filter(symbol => symbolB.has(symbol)); // Intersection
        cache.set(cacheKey, commonSymbols); // Cache the result
      }

      for (const symbol of commonSymbols) {
        const priceA = dataA[symbol];
        const priceB = dataB[symbol];

        // Get fee multipliers
        const feesA = feeMultipliers.get(exchangeA);
        const feesB = feeMultipliers.get(exchangeB);

        // Calculate prices with fees
        const buyPriceA = priceA.ask * feesA.buy;
        const sellPriceA = priceA.bid * feesA.sell;
        const buyPriceB = priceB.ask * feesB.buy;
        const sellPriceB = priceB.bid * feesB.sell;

        // Calculate margins and check arbitrage opportunities
        if (buyPriceA < sellPriceB) {
          const marginAB = ((sellPriceB - buyPriceA) / sellPriceB) * 100;
          if (marginAB >= minMarginPercent) {
            opportunities[opportunityCount++] = {
              symbol,
              buyExchange: exchangeA,
              sellExchange: exchangeB,
              buyPrice: buyPriceA,
              sellPrice: sellPriceB,
              margin: marginAB,
            };
          }
        } else if (buyPriceB < sellPriceA) {
          const marginBA = ((sellPriceA - buyPriceB) / sellPriceA) * 100;
          if (marginBA >= minMarginPercent) {
            opportunities[opportunityCount++] = {
              symbol,
              buyExchange: exchangeB,
              sellExchange: exchangeA,
              buyPrice: buyPriceB,
              sellPrice: sellPriceA,
              margin: marginBA,
            };
          }
        }
      }
    }
  }

  return opportunities
    .slice(0, opportunityCount)
    .sort((a, b) => b.margin - a.margin);
}

export async function calculateFinalReturns(
  opportunities,
  exchanges,
  USDTPrice,
  returnTypeOnOpen = null, // enum: [null, 'slip', 'spread']]
) {
  const { leverage, minVolumeUSD } = CONFIG;

  const tradeVolumeUSDT = minVolumeUSD * leverage;

  const symbolsAndSidesByExchange = {};

  for (const opportunity of opportunities) {
    const { symbol, buyExchange, sellExchange } = opportunity;

    // Process buy side
    if (!symbolsAndSidesByExchange[buyExchange]) {
      symbolsAndSidesByExchange[buyExchange] = {};
    }
    if (!symbolsAndSidesByExchange[buyExchange][symbol]) {
      symbolsAndSidesByExchange[buyExchange][symbol] = new Set();
    }
    symbolsAndSidesByExchange[buyExchange][symbol].add('buy');

    // Process sell side
    if (!symbolsAndSidesByExchange[sellExchange]) {
      symbolsAndSidesByExchange[sellExchange] = {};
    }
    if (!symbolsAndSidesByExchange[sellExchange][symbol]) {
      symbolsAndSidesByExchange[sellExchange][symbol] = new Set();
    }
    symbolsAndSidesByExchange[sellExchange][symbol].add('sell');
  }

  // Fetch VWAPs for exchanges
  const vwapResultsByExchange = {};

  await Promise.all(
    Object.entries(symbolsAndSidesByExchange).map(
      async ([exchangeId, symbolsAndSides]) => {
        const vwapResults = await getVWAPs(
          exchanges,
          exchangeId,
          Object.keys(symbolsAndSides),
          tradeVolumeUSDT,
          USDTPrice,
        );
        vwapResultsByExchange[exchangeId] = vwapResults;
      },
    ),
  );
  console.log('COMPLETE: Order books fetched\n');
  addTMNSymbols(vwapResultsByExchange, USDTPrice);

  const finalReturns = calculateFinalReturnsFromOpportunities(
    opportunities,
    vwapResultsByExchange,
    returnTypeOnOpen,
    USDTPrice,
    tradeVolumeUSDT,
  );

  return finalReturns;
}

export function calculateFinalReturnsFromOpportunities(
  opportunities,
  vwapResultsByExchange,
  returnTypeOnOpen,
  USDTPrice,
  tradeVolumeUSDT,
) {
  const { fees, slippage } = CONFIG;
  const finalReturns = [];
  for (const opportunity of opportunities) {
    const { symbol, buyExchange, sellExchange } = opportunity;

    const spreadBuyExchange =
      vwapResultsByExchange[buyExchange][symbol]?.spread;
    const spreadSellExchange =
      vwapResultsByExchange[sellExchange][symbol]?.spread;

    const buyVWAP = vwapResultsByExchange[buyExchange][symbol]?.asks;
    const sellVWAP = vwapResultsByExchange[sellExchange][symbol]?.bids;
    if (!buyVWAP || !sellVWAP) continue;
    const buyFee = fees[buyExchange].taker;
    const sellFee = fees[sellExchange].taker;

    const netBuyPrice = buyVWAP * (1 + buyFee);
    const netSellPrice = sellVWAP * (1 - sellFee);

    const profit = netSellPrice - netBuyPrice;

    const totalEntryCost = netBuyPrice + netSellPrice;
    const returnPercentage = (profit / totalEntryCost) * 100;

    const netSellPriceWithSlippage = netSellPrice * (1 - slippage);
    const netBuyPriceWithSlippage = netBuyPrice * (1 + slippage);
    const profitWithSlippage =
      netSellPriceWithSlippage - netBuyPriceWithSlippage;
    const totalEntryCostWithSlippage =
      netSellPriceWithSlippage + netBuyPriceWithSlippage;
    const returnPercentageWithSlippage =
      (profitWithSlippage / totalEntryCostWithSlippage) * 100;

    const netSellPriceWithSlippageAndSpread =
      netSellPriceWithSlippage - spreadBuyExchange;
    const netBuyPriceWithSlippageAndSpread =
      netBuyPriceWithSlippage + spreadSellExchange;
    const profitWithSlippageAndSpread =
      netSellPriceWithSlippageAndSpread - netBuyPriceWithSlippageAndSpread;
    const totalEntryCostWithSlippageAndSpread =
      netSellPriceWithSlippageAndSpread + netBuyPriceWithSlippageAndSpread;
    const returnPercentageWithSlippageAndSpread =
      (profitWithSlippageAndSpread / totalEntryCostWithSlippageAndSpread) * 100;

    let selectedBuyPrice;
    let selectedSellPrice;
    switch (returnTypeOnOpen) {
      case 'slip':
        selectedBuyPrice = netBuyPriceWithSlippage;
        selectedSellPrice = netSellPriceWithSlippage;
        break;

      case 'spread':
        selectedBuyPrice = netBuyPriceWithSlippageAndSpread;
        selectedSellPrice = netSellPriceWithSlippageAndSpread;
        break;

      default:
        selectedBuyPrice = netBuyPrice;
        selectedSellPrice = netSellPrice;
        break;
    }

    const selectedReturnPercentage =
      ((selectedSellPrice - selectedBuyPrice) / selectedSellPrice) * 100;

    finalReturns.push({
      opportunity,
      symbol,
      buyExchange,
      sellExchange,
      selectedBuyPrice,
      selectedSellPrice,
      selectedReturnPercentage,
      netBuyPrice,
      netSellPrice,
      returnPercentage,
      netBuyPriceWithSlippage,
      netSellPriceWithSlippage,
      returnPercentageWithSlippage,
      netBuyPriceWithSlippageAndSpread,
      netSellPriceWithSlippageAndSpread,
      returnPercentageWithSlippageAndSpread,
      tradeVolumeUSDT,
      USDTPrice,
    });
  }
  return finalReturns;
}


File: close/closePosition.js
--------------------------------------------------
Content of close/closePosition.js:
import { createOrder } from '../orderCreation/orderCreation.js';
import {
  moveToClosedPositions,
  updateOpenPosition,
} from '../utils/database.js';

export async function closePosition(
  exchanges,
  {
    id,
    symbol,
    buyExchange,
    sellExchange,
    amount,
    selectedBuyPrice,
    selectedSellPrice,
    tradeVolumeUSDT,
    USDTPrice,
  },
  type,
) {
  console.log(
    `Initiating position closure for ${symbol} on ${buyExchange}/${sellExchange}`,
  );

  try {
    await updateOpenPosition(id, { status: 'closing' });
    const closingOrderResult = await createOrder(
      exchanges,
      {
        symbol,
        buyExchange: sellExchange,
        sellExchange: buyExchange,
        selectedBuyPrice,
        selectedSellPrice,
        tradeVolumeUSDT,
        netBuyPrice,
        netSellPrice,
        USDTPrice,
        amount,
      },
      type,
      true,
    );

    if (!closingOrderResult) {
      throw new Error('Failed to execute closing orders');
    }

    await moveToClosedPositions(id, {
      closeBuyPrice: selectedBuyPrice,
      closeSellPrice: selectedSellPrice,
    });

    const closeTime = new Date().toISOString();
    console.log(
      `Successfully closed position for ${symbol}:`,
      `\n- Buy Exchange: ${buyExchange}`,
      `\n- Sell Exchange: ${sellExchange}`,
      `\n- Amount: ${amount}`,
      `\n- Close Time: ${closeTime}`,
    );

    return {
      success: true,
      closeTime,
      closingOrders: closingOrderResult,
      message: 'Position closed successfully',
    };
  } catch (error) {
    await updateOpenPosition(id, { status: 'open' });

    console.error(
      `Failed to close position for ${symbol} on ${buyExchange}/${sellExchange}:`,
      error.message,
    );

    throw {
      success: false,
      error: error.message,
      details: {
        symbol,
        buyExchange,
        sellExchange,
        amount,
        failureTime: Date.now(),
      },
    };
  }
}


File: orderCreation/orderCreation.js
--------------------------------------------------
Content of orderCreation/orderCreation.js:
import { findLargestPriceAndAmounPrecisions } from '../precisions/precisions.js';
import { storeOpenPosition } from '../utils/storeOpenPositions.js';
import { createExchangeOrder } from './orderExchangeCreation.js';

// Main function
export async function createOrder(
  exchanges,
  order,
  type = 'limit',
  isClose = false,
) {
  const {
    symbol,
    buyExchange,
    sellExchange,
    selectedBuyPrice,
    selectedSellPrice,
    tradeVolumeUSDT,
    USDTPrice,
  } = order;

  const { pricePrecision, amountPrecision } =
    findLargestPriceAndAmounPrecisions(symbol);

  const priceDecimals = Math.floor(Math.log10(pricePrecision));

  const USDTAmount = symbol.endsWith('/USDT')
    ? tradeVolumeUSDT / ((selectedBuyPrice + selectedSellPrice) / 2)
    : (tradeVolumeUSDT * USDTPrice) /
      ((selectedBuyPrice + selectedSellPrice) / 2);
  const roundedUSDTAmount =
    Math.floor(USDTAmount / amountPrecision) * amountPrecision;

  const amountToTrade = roundedUSDTAmount;

  console.log(
    `Placing orders: Buy ${amountToTrade.toFixed(
      6,
    )} ${symbol} on ${buyExchange}, Sell on ${sellExchange}`,
  );

  let buyOrder, sellOrder;

  if (amountToTrade === 0) {
    console.log('WARNING: "amountToTrade" is zero, skipping order creation');
    return;
  }
  const [buyResult, sellResult] = await Promise.allSettled([
    createExchangeOrder(
      buyExchange,
      symbol,
      type,
      'buy',
      amountToTrade,
      selectedBuyPrice,
      exchanges,
      USDTPrice,
      priceDecimals,
    ),
    createExchangeOrder(
      sellExchange,
      symbol,
      type,
      'sell',
      amountToTrade,
      selectedSellPrice,
      exchanges,
      USDTPrice,
      priceDecimals,
    ),
  ]);

  if (buyResult.status === 'fulfilled') {
    buyOrder = buyResult.value;
  } else {
    console.error('Buy order failed:', buyResult.reason);
  }

  if (sellResult.status === 'fulfilled') {
    sellOrder = sellResult.value;
  } else {
    console.error('Sell order failed:', sellResult.reason);
  }
  // Store Open Position if successful
  if (buyOrder && sellOrder && !isClose) {
    storeOpenPosition({
      symbol,
      buyExchange,
      sellExchange,
      amount: amountToTrade,
      entryBuyPrice: buyOrder?.average || selectedBuyPrice,
      entrySellPrice: sellOrder?.average || selectedSellPrice,
      USDTPrice,
    });
  }
}


File: orderCreation/orderExchangeCreation.js
--------------------------------------------------
Content of orderCreation/orderExchangeCreation.js:
import axios from 'axios';
import { CONFIG } from '../config.js';
import { originalizeSpecialCoinOrder } from '../transforms/originalizations.js';

export async function createExchangeOrder(
  exchangeId,
  symbol,
  type,
  side,
  amount,
  price,
  exchanges,
  USDTPrice,
  pricePrecision,
) {
  switch (exchangeId) {
    case 'nobitex':
      return createNobitexOrder(
        symbol,
        type,
        side,
        amount,
        price,
        pricePrecision,
      );

    case 'wallex':
      return createWallexOrder(
        symbol,
        type,
        side,
        amount,
        price,
        pricePrecision,
      );

    default:
      let convertedValues;
      if (symbol.endsWith('/TMN')) {
        convertedValues = convertTMNOrderToUSDT(symbol, price, USDTPrice);
      }
      const convertedSymbol = convertedValues?.convertedSymbol || symbol;
      const convertedPrice = convertedValues?.convertedPrice || price;

      return exchanges[exchangeId].createOrder(
        convertedSymbol,
        type,
        side,
        amount,
        convertedPrice,
      );
  }
}

async function createNobitexOrder(
  symbol,
  type,
  side,
  amount,
  price,
  priceDecimals,
) {
  const { exchangeParams } = CONFIG;
  const apiKey = exchangeParams.nobitex.apiKey;

  // Nobitex expects the symbol in a specific format (e.g., 'BTCIRT')
  const [base, quote] = symbol.split('/');

  let {
    transformedBase: nobitexBase,
    transformedAmount: nobitexAmount,
    transformedPrice: nobitexPrice,
  } = originalizeSpecialCoinOrder('nobitex', base, amount, price);

  const url = 'https://testnetapi.nobitex.ir/market/orders/add';
  console.log(apiKey);
  const headers = {
    Authorization: `Token ${apiKey}`,
    'Content-Type': 'application/json',
    UserAgent: `TraderBot/19977`,
  };
  const dstCurrency = quote === 'TMN' ? 'rls' : 'usdt';
  let srcCurrency = nobitexBase.toLowerCase();
  nobitexPrice = quote === 'TMN' ? nobitexPrice * 10 : nobitexPrice;

  let body = {
    type: side,
    execution: type,
    srcCurrency,
    dstCurrency,
    amount: nobitexAmount.toString(),
    price: nobitexPrice.toFixed(priceDecimals),
  };

  try {
    const response = await axios.post(url, body, { headers });
    if (response.data.status === 'failed') {
      throw new Error(
        `Nobitex order creation failed: ${JSON.stringify(response.data)}`,
      );
    }
    console.log(
      `Nobitex order created successfully: ${JSON.stringify(response.data)}`,
    );
    return response.data;
  } catch (error) {
    console.error(
      `Error creating Nobitex order: ${
        error.response ? JSON.stringify(error.response.data) : error.message
      }`,
    );
    throw error;
  }
}

async function createWallexOrder(
  symbol,
  type,
  side,
  amount,
  price,
  priceDecimals,
) {
  const { exchangeParams } = CONFIG;
  const apiKey = exchangeParams.wallex.apiKey;

  const [base, quote] = symbol.split('/');

  let {
    transformedBase: wallexBase,
    transformedAmount: wallexAmount,
    transformedPrice: wallexPrice,
  } = originalizeSpecialCoinOrder('wallex', base, amount, price);

  // Wallex expects the symbol in a specific format (e.g., 'BTCUSDT')
  const wallexSymbol = wallexBase + quote;

  const url = 'https://api.wallex.ir/v1/order/create';
  const timestamp = Date.now();

  const body = {
    symbol: wallexSymbol,
    type,
    side,
    quantity: wallexAmount.toString(),
    price: wallexPrice.toFixed(priceDecimals),
    timestamp,
  };

  const headers = {
    'x-api-key': apiKey,
    'Content-Type': 'application/json',
  };

  try {
    const response = await axios.post(url, body, { headers });

    if (response.data.code !== 201 && response.data.code !== 200) {
      throw new Error(
        `Wallex order creation failed: ${JSON.stringify(response.data)}`,
      );
    }

    console.log(
      `Wallex order created successfully: ${JSON.stringify(response.data)}`,
    );
    return response.data;
  } catch (error) {
    console.error(
      `Error creating Wallex order: ${
        error.response ? JSON.stringify(error.response.data) : error.message
      }`,
    );
    throw error;
  }
}

function convertTMNOrderToUSDT(symbol, price, USDTPrice) {
  const convertedSymbol = symbol.replace('/TMN', '/USDT');
  const convertedPrice = price / USDTPrice;

  return { convertedSymbol, convertedPrice };
}


File: precisions/precisions.js
--------------------------------------------------
Content of precisions/precisions.js:
import axios from 'axios';
import { standardizeSpecialCoinPrecisions } from '../transforms/standardizations.js';

// precisions example: 0.0000001
async function getNobitexPrecisions() {
  try {
    const response = await axios.get(
      'https://testnetapi.nobitex.ir/v2/options',
    );
    const { amountPrecisions, pricePrecisions } = response.data.nobitex;
    const nobitexPricePrecisions = {};
    const nobitexAmountPrecisions = {};

    for (const originalSymbol in pricePrecisions) {
      let base = originalSymbol.replace(/(IRT|USDT)$/, '');
      let quote = originalSymbol.replace(new RegExp(`^${base}`), '');
      quote = quote === 'IRT' ? 'TMN' : quote;
      const standardizedSymbol = base + '/' + quote;
      nobitexPricePrecisions[standardizedSymbol] = parseFloat(
        pricePrecisions[originalSymbol],
      );
    }
    for (const originalSymbol in amountPrecisions) {
      const base = originalSymbol.replace(/(IRT|USDT)$/, '');
      const quote = originalSymbol.replace(new RegExp(`^${base}`), '');
      const standardizedSymbol = base + '/' + quote;
      nobitexAmountPrecisions[standardizedSymbol] = parseFloat(
        amountPrecisions[originalSymbol],
      );
    }
    const nobitexPrecisions = {
      amountPrecisions: nobitexAmountPrecisions,
      pricePrecisions: nobitexPricePrecisions,
    };
    standardizeSpecialCoinPrecisions('nobitex', nobitexPrecisions);
    return nobitexPrecisions;
  } catch (error) {
    console.error('Error fetching nobitex precisions:', error);
  }
}

async function getWallexPrecisions() {
  try {
    const response = await axios.get('https://api.wallex.ir/v1/markets');
    const precisions = response.data.result.symbols;

    const wallexAmountPrecisions = {};
    const wallexPricePrecisions = {};
    for (const originalSymbol in precisions) {
      const precision = precisions[originalSymbol];
      const base = precision.baseAsset;
      const quote = precision.quoteAsset;

      const standardizedSymbol = base + '/' + quote;
      wallexAmountPrecisions[standardizedSymbol] = precision.minQty;
      wallexPricePrecisions[standardizedSymbol] = precision?.quotePrecision
        ? 10 ** -precision.quotePrecision
        : 10 ** -precision?.quoteAssetPrecision;
    }
    const wallexPrecisions = {
      amountPrecisions: wallexAmountPrecisions,
      pricePrecisions: wallexPricePrecisions,
    };
    standardizeSpecialCoinPrecisions('wallex', wallexPrecisions);
    return wallexPrecisions;
  } catch (error) {}
}

const nobitexPrecisions = await getNobitexPrecisions();
const wallexPrecisions = await getWallexPrecisions();

export function findLargestPriceAndAmounPrecisions(symbol) {
  const pricePrecisions = [
    nobitexPrecisions.pricePrecisions[symbol],
    wallexPrecisions.pricePrecisions[symbol],
  ];
  const amountPrecisions = [
    nobitexPrecisions.amountPrecisions[symbol],
    wallexPrecisions.amountPrecisions[symbol],
  ];

  const amountPrecision = Math.max(...amountPrecisions);
  const pricePrecision = Math.max(...pricePrecisions);
  const precision = { amountPrecision, pricePrecision };

  return precision;
}


File: utils/database.js
--------------------------------------------------
Content of utils/database.js:
import sqlite3 from 'sqlite3';
import { CONFIG } from '../config.js';

const { databaseName } = CONFIG;
const db = new sqlite3.Database(databaseName, err => {
  if (err) {
    console.error('Error opening database:', err.message);
  } else {
    console.log('Connected to the SQLite database.');
  }
});
// Extend the existing database setup
db.serialize(() => {
  db.run(
    `
        CREATE TABLE IF NOT EXISTS positions (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          symbol TEXT NOT NULL,
          buyExchange TEXT NOT NULL,
          sellExchange TEXT NOT NULL,
          amount REAL NOT NULL,
          entryBuyPrice REAL NOT NULL,
          entrySellPrice REAL NOT NULL,
          timestamp INTEGER NOT NULL,
          status TEXT DEFAULT 'open'
        )
      `,
    err => {
      if (err) {
        console.error('Error creating positions table:', err.message);
      } else {
        console.log('Positions table created or already exists.');
      }
    },
  );

  db.run(
    `CREATE TABLE IF NOT EXISTS closed_positions (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        symbol TEXT NOT NULL,
        buyExchange TEXT NOT NULL,
        sellExchange TEXT NOT NULL,
        amount REAL NOT NULL,
        entryBuyPrice REAL NOT NULL,
        entrySellPrice REAL NOT NULL,
        closeBuyPrice REAL NOT NULL,
        closeSellPrice REAL NOT NULL,
        USDTPrice REAL NOT NULL,
        timestamp INTEGER NOT NULL,
        closeTimestamp INTEGER NOT NULL
      )`,
    err => {
      if (err) {
        console.error('Error creating closed_positions table:', err.message);
      } else {
        console.log('Closed positions table created or already exists.');
      }
    },
  );
});

// Function to update an open position
function updateOpenPosition(id, updates) {
  return new Promise((resolve, reject) => {
    const fields = Object.keys(updates)
      .map(key => `${key} = ?`)
      .join(', ');
    const values = [...Object.values(updates), id];
    db.run(
      `UPDATE positions SET ${fields} WHERE id = ?`,
      values,
      function (err) {
        if (err) {
          console.error('Error updating position:', err.message);
          reject(err);
        } else if (this.changes === 0) {
          reject(new Error('No position found to update'));
        } else {
          console.log(`Position with ID ${id} updated.`);
          resolve();
        }
      },
    );
  });
}

// Function to move a position to the closed_positions table
function moveToClosedPositions(positionId, closingDetails) {
  return new Promise((resolve, reject) => {
    db.get(
      `SELECT * FROM positions WHERE id = ?`,
      [positionId],
      (err, position) => {
        if (err) {
          console.error('Error fetching position to close:', err.message);
          reject(err);
          return;
        }
        if (!position) {
          reject(new Error(`Position with ID ${positionId} not found.`));
          return;
        }

        const closeTimestamp = Date.now();
        db.run(
          `INSERT INTO closed_positions 
            (symbol, buyExchange, sellExchange, amount, entryBuyPrice, entrySellPrice, closeBuyPrice, closeSellPrice, USDTPrice, timestamp, closeTimestamp)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
          [
            position.symbol,
            position.buyExchange,
            position.sellExchange,
            position.amount,
            position.entryBuyPrice,
            position.entrySellPrice,
            closingDetails.closeBuyPrice,
            closingDetails.closeSellPrice,
            position.USDTPrice,
            position.timestamp,
            closeTimestamp,
          ],
          function (insertErr) {
            if (insertErr) {
              console.error(
                'Error moving position to closed_positions:',
                insertErr.message,
              );
              reject(insertErr);
              return;
            }

            // Delete from the open positions table after moving
            db.run(
              `DELETE FROM positions WHERE id = ?`,
              [positionId],
              function (deleteErr) {
                if (deleteErr) {
                  console.error(
                    'Error removing open position:',
                    deleteErr.message,
                  );
                  reject(deleteErr);
                  return;
                }
                console.log(
                  `Position with ID ${positionId} moved to closed_positions.`,
                );
                resolve();
              },
            );
          },
        );
      },
    );
  });
}

function storePosition(position) {
  return new Promise((resolve, reject) => {
    const {
      symbol,
      buyExchange,
      sellExchange,
      amount,
      entryBuyPrice,
      entrySellPrice,
      USDTPrice,
    } = position;
    const timestamp = Date.now();
    db.run(
      `INSERT INTO positions (symbol, buyExchange, sellExchange, amount, entryBuyPrice, entrySellPrice, USDTPrice, timestamp)
         VALUES (?, ?, ?, ?, ?, ?, ?)`,
      [
        symbol,
        buyExchange,
        sellExchange,
        amount,
        entryBuyPrice,
        entrySellPrice,
        USDTPrice,
        timestamp,
      ],
      function (err) {
        if (err) {
          console.error('Error storing position:', err.message);
          reject(err);
        } else {
          console.log(`Position stored with ID: ${this.lastID}`);
          resolve(this.lastID);
        }
      },
    );
  });
}

function getOpenPositions() {
  return new Promise((resolve, reject) => {
    db.all(`SELECT * FROM positions`, [], (err, rows) => {
      if (err) {
        console.error('Error fetching open positions:', err.message);
        reject(err);
      } else {
        resolve(rows);
      }
    });
  });
}

function removePosition(positionId) {
  return new Promise((resolve, reject) => {
    db.run(`DELETE FROM positions WHERE id = ?`, positionId, function (err) {
      if (err) {
        console.error('Error removing position:', err.message);
        reject(err);
      } else {
        console.log(`Position with ID ${positionId} removed.`);
        resolve();
      }
    });
  });
}

// Close the database connection when the application exits
process.on('exit', () => {
  db.close(err => {
    if (err) {
      console.error('Error closing the database:', err.message);
    } else {
      console.log('Database connection closed.');
    }
  });
});

// Handle SIGINT (Ctrl+C) to gracefully close the database connection
process.on('SIGINT', () => {
  console.log('Closing database connection...');
  db.close(err => {
    if (err) {
      console.error('Error closing the database:', err.message);
    } else {
      console.log('Database connection closed.');
    }
  });
  process.exit();
});

// Export the new functions
export {
  storePosition,
  getOpenPositions,
  removePosition,
  updateOpenPosition,
  moveToClosedPositions,
};


File: utils/addTMNSymbols.js
--------------------------------------------------
Content of utils/addTMNSymbols.js:
import { CONFIG } from '../config.js';
import { splitSymbolsIntoQuoteAndBase } from './splitSymbols.js';

export function addTMNSymbols(VWAPsByExchange, USDTPrice) {
  const { customExchanges } = CONFIG;
  for (const exchangeId in VWAPsByExchange) {
    if (customExchanges.includes(exchangeId)) continue;

    const quotesMap = splitSymbolsIntoQuoteAndBase(null, exchangeId);

    if (quotesMap.USDT?.length) {
      for (const symbol in VWAPsByExchange[exchangeId]) {
        let TMNSymbol = symbol.replace('/USDT', '/TMN');
        VWAPsByExchange[exchangeId][TMNSymbol] = {};
        VWAPsByExchange[exchangeId][TMNSymbol].asks =
          VWAPsByExchange[exchangeId][symbol].asks * USDTPrice;
        VWAPsByExchange[exchangeId][TMNSymbol].bids =
          VWAPsByExchange[exchangeId][symbol].bids * USDTPrice;
        VWAPsByExchange[exchangeId][TMNSymbol].spread =
          VWAPsByExchange[exchangeId][symbol].spread * USDTPrice;
      }
    }
  }
  return;
}


File: utils/splitSymbols.js
--------------------------------------------------
Content of utils/splitSymbols.js:
import NodeCache from 'node-cache';

const baseCache = new NodeCache({
  stdTTL: 600, // cache expires after 10 minute
});
const quoteCache = new NodeCache({
  stdTTL: 600, // cache expires after 10 minute
});

export function splitSymbolsIntoBaseAndQuote(symbols, exchangeId, skipCaching) {
  const key = exchangeId;
  const cachedValue = baseCache.get(key);
  if (cachedValue) {
    return cachedValue;
  }

  const basesMap = {};
  for (const symbol of symbols) {
    const [base, quote] = symbol.split('/');
    if (!basesMap[base]) {
      basesMap[base] = [];
    }
    basesMap[base].push(symbol);
  }
  if (!skipCaching) baseCache.set(key, basesMap);
  return basesMap;
}

export function splitSymbolsIntoQuoteAndBase(
  symbols,
  exchangeId,
  recalculate = false,
) {
  const key = exchangeId;
  const cachedValue = quoteCache.get(key);
  if (cachedValue && !recalculate) {
    return cachedValue;
  }

  const quotesMap = {};
  for (const symbol in symbols) {
    const [base, quote] = symbol.split('/');
    if (!quotesMap[quote]) {
      quotesMap[quote] = [];
    }
    quotesMap[quote].push(symbol);
  }

  quoteCache.set(key, quotesMap);
  return quotesMap;
}


File: utils/calculateTMNPrice.js
--------------------------------------------------
Content of utils/calculateTMNPrice.js:
import { CONFIG } from '../config.js';
import { splitSymbolsIntoQuoteAndBase } from './splitSymbols.js';

export function calculateTMNPrice(allPrices, USDTPrice) {
  const { customExchanges = [] } = CONFIG;
  for (const exchange in allPrices) {
    if (customExchanges.includes(exchange)) continue;

    const symbols = allPrices[exchange];

    const quotesMap = splitSymbolsIntoQuoteAndBase(symbols, exchange);
    if (quotesMap.USDT?.length) {
      for (const symbol of quotesMap['USDT']) {
        let TMNSymbol = symbol.replace('/USDT', '/TMN');
        symbols[TMNSymbol] = {};
        symbols[TMNSymbol].ask = symbols[symbol].ask * USDTPrice;
        symbols[TMNSymbol].bid = symbols[symbol].bid * USDTPrice;
      }
      if (!quotesMap.hasOwnProperty('TMN')) {
        splitSymbolsIntoQuoteAndBase(symbols, exchange, true);
      }
    }
  }
}


File: utils/storeOpenPositions.js
--------------------------------------------------
Content of utils/storeOpenPositions.js:
import { storePosition } from './database.js'; // ensure correct path

export async function storeOpenPosition({
  symbol,
  buyExchange,
  sellExchange,
  amount,
  entryBuyPrice,
  entrySellPrice,
}) {
  await storePosition({
    symbol,
    buyExchange,
    sellExchange,
    amount,
    entryBuyPrice,
    entrySellPrice,
  });
  console.log('Open position stored in DB.');
}


File: VWAP/VWAP.js
--------------------------------------------------
Content of VWAP/VWAP.js:
import { fetchOrderBooks } from '../fetch/fetchOrderBooks.js';

export async function getVWAPs(
  exchanges,
  exchangeId,
  symbols,
  tradeVolumeUSDT,
  USDTPrice,
) {
  try {
    const orderBooks = await fetchOrderBooks(exchanges, exchangeId, symbols);

    const VWAPs = calculateVWAPs(orderBooks, tradeVolumeUSDT, USDTPrice);

    return VWAPs;
  } catch (error) {
    console.error(`Error fetching VWAPs for ${exchangeId}:`, error.message);
    return {};
  }
}

// Calculate Volume Weighted Average Price (VWAP)
export function calculateVWAPs(orderBooks, tradeVolumeUSDT, USDTPrice) {
  let VWAPs = {};
  let tradeVolume = {
    USDT: tradeVolumeUSDT,
    TMN: tradeVolumeUSDT * USDTPrice,
  };
  for (let symbol in orderBooks) {
    VWAPs[symbol] = {};
    let [_, quote] = symbol.split('/');
    let orderBook = orderBooks[symbol];

    for (let side of ['asks', 'bids']) {
      let accumulatedVolume = 0;
      let accumulatedCost = 0;
      let orders = orderBook[side];
      for (const [price, amount] of orders) {
        const orderCost = price * amount;
        if (accumulatedCost + orderCost >= tradeVolume[quote]) {
          const remainingCost = tradeVolume[quote] - accumulatedCost;
          const partialAmount = remainingCost / price;
          accumulatedVolume += partialAmount;
          accumulatedCost += remainingCost;
          VWAPs[symbol][side] = accumulatedCost / accumulatedVolume;
          break;
        } else {
          accumulatedVolume += amount;
          accumulatedCost += orderCost;
        }
      }
    }
    VWAPs[symbol].spread = VWAPs[symbol]?.asks - VWAPs[symbol]?.bids;
  }
  return VWAPs;
}


File: fetch/fetchOrderBooks.js
--------------------------------------------------
Content of fetch/fetchOrderBooks.js:
import axios from 'axios';
import {
  standardizeNobitexOrderBooks,
  standardizeWallexOrderBooks,
} from '../transforms/standardizations.js';
import { splitSymbolsIntoQuoteAndBase } from '../utils/splitSymbols.js';

// Fetch Nobitex L2 Order Books
export async function fetchNobitexOrderBooks(symbols) {
  try {
    const response = await axios.get(
      'https://testnetapi.nobitex.ir/v3/orderbook/all',
    );
    const data = response.data;

    if (!data) {
      throw new Error('No order book data available from Nobitex');
    }

    delete data.status;

    const nobitexOrderBooks = standardizeNobitexOrderBooks(data, symbols);

    console.log('Nobitex order books fetched');
    return nobitexOrderBooks;
  } catch (error) {
    console.error('Error fetching Nobitex order books:', error);
    return {};
  }
}

// Fetch Wallex L2 Order Books
export async function fetchWallexOrderBooks(symbols) {
  try {
    const response = await axios.get('https://api.wallex.ir/v2/depth/all');
    const data = response.data.result;

    if (!data) {
      throw new Error('No order book data available from Wallex');
    }
    const wallexOrderBooks = standardizeWallexOrderBooks(data, symbols);

    console.log('Wallex order books fetched');
    return wallexOrderBooks;
  } catch (error) {
    console.error('Error fetching Wallex order books:', error.message);
    return {};
  }
}

export async function fetchOrderBooks(exchanges, exchangeId, symbols) {
  try {
    const orderBooks = {};
    const quotesMap = splitSymbolsIntoQuoteAndBase(symbols, exchangeId);
    if (exchangeId === 'nobitex') {
      const nobitexOrderBooks = await fetchNobitexOrderBooks(symbols);
      Object.assign(orderBooks, nobitexOrderBooks);
    } else if (exchangeId === 'wallex') {
      const wallexOrderBooks = await fetchWallexOrderBooks(symbols);
      Object.assign(orderBooks, wallexOrderBooks);
    } else {
      // For CCXT exchanges
      if (exchanges[exchangeId].has.fetchOrderBooks) {
        const exchangeOrderBooks = await exchanges[exchangeId].fetchOrderBooks(
          symbols,
        );
        Object.assign(orderBooks, exchangeOrderBooks);
      } else {
        const orderBooksPromises = symbols
          .filter(symbol => !quotesMap.TMN.includes(symbol))
          .map(async symbol => {
            try {
              const orderBook = await exchanges[exchangeId].fetchOrderBook(
                symbol,
              );
              orderBooks[symbol] = orderBook;
            } catch (err) {
              console.error(`Error fetching order book for ${symbol}:`, err);
            }
          });
        await Promise.allSettled(orderBooksPromises);
      }

      console.log(
        `${exchangeId.charAt(0).toUpperCase()}${exchangeId.slice(
          1,
        )} order books fetched`,
      );
    }

    return orderBooks;
  } catch (error) {
    console.error(`Error fetching VWAPs for ${exchangeId}:`, error.message);
    return {};
  }
}


File: fetch/fetchPrices.js
--------------------------------------------------
Content of fetch/fetchPrices.js:
import ccxt from 'ccxt';
import axios from 'axios';
import { CONFIG } from '../config.js';

// Function to fetch prices from Nobitex (custom implementation)
export async function fetchNobitexPrices() {
  const { coinsToConsider, coinsToIgnore } = CONFIG;
  try {
    const response = await axios.get(
      'https://testnetapi.nobitex.ir/v3/orderbook/all',
    );
    const data = response.data;
    delete data.status;
    const prices = {};

    for (const symbol in data) {
      let base = symbol.replace(/(IRT|USDT)$/, '');
      let quote = symbol.replace(new RegExp(`^${base}`), '');

      if (
        (coinsToConsider && !coinsToConsider.includes(base)) ||
        coinsToIgnore.includes(base)
      ) {
        continue;
      }
      // Asks and Bids are opposite to other exchanges
      const bids = data[symbol].bids;
      const asks = data[symbol].asks;

      if (bids?.length > 0 && asks?.length > 0) {
        let bidPrice = parseFloat(bids[0][0]);
        let askPrice = parseFloat(asks[0][0]);

        if (quote === 'IRT') {
          bidPrice /= 10;
          askPrice /= 10;
          quote = 'TMN';
        }

        prices[base + '/' + quote] = {
          bid: bidPrice,
          ask: askPrice,
        };
      }
    }

    console.log('Nobitex prices fetched');
    return prices;
  } catch (error) {
    console.error('Error fetching Nobitex prices:', error);
    return {};
  }
}

// Function to fetch prices from Wallex (custom implementation)
export async function fetchWallexPrices() {
  const { coinsToConsider, coinsToIgnore } = CONFIG;
  try {
    const response = await axios.get('https://api.wallex.ir/v1/markets');
    const symbols = response.data.result.symbols;

    const prices = {};

    for (const symbol in symbols) {
      const ticker = symbols[symbol];
      const base = ticker.baseAsset;
      const quote = ticker.quoteAsset;

      if (
        (coinsToConsider && !coinsToConsider.includes(base)) ||
        coinsToIgnore.includes(base)
      ) {
        continue;
      }

      const bidPrice = parseFloat(ticker.stats.bidPrice);
      const askPrice = parseFloat(ticker.stats.askPrice);

      prices[base + '/' + quote] = {
        bid: bidPrice,
        ask: askPrice,
      };
    }

    console.log('Wallex prices fetched');
    return prices;
  } catch (error) {
    console.error('Error fetching Wallex prices:', error.message);
    return {};
  }
}

// Function to fetch all prices concurrently
export async function fetchAllPrices(exchanges) {
  const { exchangesToUse } = CONFIG;
  const allPrices = {};
  const fetchPromises = exchangesToUse.map(async exchangeId => {
    if (exchangeId === 'nobitex') {
      allPrices[exchangeId] = await fetchNobitexPrices();
    } else if (exchangeId === 'wallex') {
      allPrices[exchangeId] = await fetchWallexPrices();
    } else {
      allPrices[exchangeId] = await fetchPrices(exchanges, exchangeId);
    }
  });

  await Promise.all(fetchPromises);
  return allPrices;
}

// Function to fetch prices from an exchange
export async function fetchPrices(exchanges, exchangeId) {
  const { coinsToConsider, coinsToIgnore } = CONFIG;
  try {
    const exchange = exchanges[exchangeId];
    // await exchange.loadMarkets();
    const tickers = await exchange.fetchTickers();
    const prices = {};

    for (const symbol in tickers) {
      const ticker = tickers[symbol];
      const [base, quote] = symbol.split('/');

      if (
        (coinsToConsider && !coinsToConsider.includes(base)) ||
        coinsToIgnore.includes(base)
      ) {
        continue;
      }

      //! make sure to check the ticker of each exchange, because
      //! sometimes bid and ask are not available.
      prices[symbol] = {
        bid: ticker.bid || ticker.close,
        ask: ticker.ask || ticker.close,
      };
    }

    console.log(
      `${exchangeId.charAt(0).toUpperCase()}${exchangeId.slice(
        1,
      )} prices fetched`,
    );
    return prices;
  } catch (error) {
    console.error(`Error fetching prices from ${exchangeId}:`, error.message);
    return {};
  }
}


File: transforms/originalizations.js
--------------------------------------------------
Content of transforms/originalizations.js:
import { CONFIG } from '../config.js';

export function originalizeSpecialCoinOrder(exchangeId, base, amount, price) {
  const { specialCoinStandardizations } = CONFIG;

  const standardizations = specialCoinStandardizations[exchangeId];
  const standardization = standardizations.find(s => s.standardBase === base);

  if (!standardization) {
    // If no special standardization is found, return original values
    return {
      transformedBase: base,
      transformedAmount: amount,
      transformedPrice: price,
    };
  }

  const { originalBase, correctionFactor } = standardization;

  const transformedBase = originalBase;
  const transformedAmount = amount * correctionFactor;
  const transformedPrice = price / correctionFactor;

  const transformedValues = {
    transformedBase,
    transformedAmount,
    transformedPrice,
  };

  return transformedValues;
}


File: transforms/standardizations.js
--------------------------------------------------
Content of transforms/standardizations.js:
import { CONFIG } from '../config.js';
import { splitSymbolsIntoBaseAndQuote } from '../utils/splitSymbols.js';

export function standardizeNobitexOrderBooks(nobitexOrderBooks, symbols) {
  const orderBooks = {};
  for (let symbol in nobitexOrderBooks) {
    const base = symbol.replace(/(IRT|USDT)$/, '');
    let quote = symbol.replace(new RegExp(`^${base}`), '');

    const factor = quote === 'IRT' ? 10 : 1;
    if (quote === 'IRT') {
      quote = 'TMN';
    }

    const standardizedSymbol = base + '/' + quote;

    if (!symbols.includes(standardizedSymbol)) continue;

    const asks = nobitexOrderBooks[symbol].asks.map(([price, amount]) => [
      parseFloat(price) / factor,
      parseFloat(amount),
    ]);
    const bids = nobitexOrderBooks[symbol].bids.map(([price, amount]) => [
      parseFloat(price) / factor,
      parseFloat(amount),
    ]);

    orderBooks[standardizedSymbol] = {
      asks,
      bids,
    };
  }

  standardizeSpecialCoinOrderBooks('nobitex', orderBooks);
  return orderBooks;
}
export function standardizeWallexOrderBooks(wallexOrderBooks, symbols) {
  const orderBooks = {};

  for (const symbol in wallexOrderBooks) {
    const orderBook = wallexOrderBooks[symbol];

    const base = symbol.replace(/(TMN|USDT)$/, '');
    let quote = symbol.replace(new RegExp(`^${base}`), '');

    const standardizedSymbol = base + '/' + quote;

    if (!symbols.includes(standardizedSymbol)) continue;

    const asks = orderBook.ask
      .slice(0, 24)
      .map(order => [parseFloat(order.price), parseFloat(order.quantity)]);
    const bids = orderBook.bid
      .slice(0, 24)
      .map(order => [parseFloat(order.price), parseFloat(order.quantity)]);

    orderBooks[standardizedSymbol] = {
      asks,
      bids,
    };
  }

  standardizeSpecialCoinOrderBooks('wallex', orderBooks);
  return orderBooks;
}

export function standardizeSpecialCoinOrderBooks(exchangeId, orderBooks) {
  const { specialCoinStandardizations } = CONFIG;

  const standardizations = specialCoinStandardizations[exchangeId];
  const symbols = Object.keys(orderBooks);
  const basesMap = splitSymbolsIntoBaseAndQuote(symbols, exchangeId);

  for (let i = 0; i < standardizations.length; i++) {
    const { originalBase, standardBase, correctionFactor } =
      standardizations[i];

    if (!basesMap[originalBase]) return;

    for (const originalSymbol of basesMap[originalBase]) {
      if (!orderBooks[originalSymbol]) continue;
      const { bids, asks } = orderBooks[originalSymbol];
      const standardSymbol = originalSymbol.replace(originalBase, standardBase);

      orderBooks[standardSymbol] = {
        bids: bids.map(bid => bid * correctionFactor),
        asks: asks.map(ask => ask * correctionFactor),
      };

      delete orderBooks[originalSymbol];
    }
  }
}

export function standardizeSpecialCoinPrices(allPrices) {
  const { specialCoinStandardizations, exchangesToUse } = CONFIG;
  for (const exchangeId in specialCoinStandardizations) {
    if (!exchangesToUse.includes(exchangeId)) continue;
    const standardizations = specialCoinStandardizations[exchangeId];

    const symbols = Object.keys(allPrices[exchangeId]);
    const basesMap = splitSymbolsIntoBaseAndQuote(symbols, exchangeId);

    for (let i = 0; i < standardizations.length; i++) {
      const { originalBase, standardBase, correctionFactor } =
        standardizations[i];
      if (allPrices[exchangeId] && basesMap[originalBase]) {
        const priceData = allPrices[exchangeId];
        if (!priceData[originalBase]) {
          continue;
        }
        for (const originalSymbol of basesMap[originalBase]) {
          const { bid, ask } = priceData[originalSymbol];
          const standardSymbol = originalSymbol.replace(
            originalBase,
            standardBase,
          );
          allPrices[exchangeId][standardSymbol] = {
            bid: bid * correctionFactor,
            ask: ask * correctionFactor,
          };
          delete allPrices[exchangeId][originalSymbol];
        }
      }
    }
  }
}

export function standardizeSpecialCoinPrecisions(exchangeId, precisions) {
  const { specialCoinStandardizations } = CONFIG;
  const standardizations = specialCoinStandardizations[exchangeId];

  const symbols = Object.keys(precisions.pricePrecisions);
  const skipCaching = true;
  const basesMap = splitSymbolsIntoBaseAndQuote(
    symbols,
    exchangeId,
    skipCaching,
  );

  for (let i = 0; i < standardizations.length; i++) {
    const { originalBase, standardBase, correctionFactor } =
      standardizations[i];

    for (const originalSymbol of basesMap[originalBase]) {
      if (!precisions.pricePrecisions[originalSymbol]) {
        continue;
      }
      const pricePrecision = precisions.pricePrecisions[originalSymbol];
      const standardSymbol = originalSymbol.replace(originalBase, standardBase);
      precisions.pricePrecisions[standardSymbol] = pricePrecision;

      delete precisions.pricePrecisions[originalSymbol];
    }

    for (const originalSymbol of basesMap[originalBase]) {
      if (!precisions.pricePrecisions[originalSymbol]) {
        continue;
      }
      const amountPrecision = precisions.amountPrecisions[originalSymbol];
      const standardSymbol = originalSymbol.replace(originalBase, standardBase);
      precisions.amountPrecisions[standardSymbol] =
        amountPrecision * correctionFactor;

      delete precisions.amountPrecisions[originalSymbol];
    }
  }
}


File: monitoring/monitoring.js
--------------------------------------------------
Content of monitoring/monitoring.js:
import { CONFIG } from '../config.js';
import { getVWAPs } from '../VWAP/VWAP.js';
import { closePosition } from '../close/closePosition.js';
import { addTMNSymbols } from '../utils/addTMNSymbols.js';
import { getOpenPositions } from '../utils/database.js';

export async function monitorOpenPositions(exchanges, USDTPrice) {
  const {
    orderTypeOnClose,
    tradeVolumeUSDT,
    returnTypeOnClose,
    closeMinMarginPercent,
  } = CONFIG;

  // Fetch open positions from the database
  let openPositions = [];
  try {
    openPositions = await getOpenPositions();
  } catch (error) {
    console.error('Failed to fetch open positions from the database:', error);
    return; // Exit early if we can't get positions
  }

  if (!openPositions?.length) {
    console.log('No open positions to monitor.');
    return;
  }

  console.log('Monitoring open positions...');

  const exchangeMap = {};

  // Loop through each position
  for (const position of openPositions) {
    const { symbol, buyExchange, sellExchange } = position;

    // Add symbol to buyExchange
    if (!exchangeMap[buyExchange]) {
      exchangeMap[buyExchange] = new Set(); // Use a Set to ensure uniqueness
    }
    exchangeMap[buyExchange].add(symbol);

    // Add symbol to sellExchange
    if (!exchangeMap[sellExchange]) {
      exchangeMap[sellExchange] = new Set(); // Use a Set to ensure uniqueness
    }
    exchangeMap[sellExchange].add(symbol);
  }

  // Convert Sets back to arrays
  for (const exchange in exchangeMap) {
    exchangeMap[exchange] = Array.from(exchangeMap[exchange]);
  }
  const vwapResultsByExchange = {};
  await Promise.all(
    Object.entries(exchangeMap).map(async ([exchangeId, symbols]) => {
      const vwapResults = await getVWAPs(
        exchanges,
        exchangeId,
        symbols,
        tradeVolumeUSDT,
        USDTPrice,
      );
      vwapResultsByExchange[exchangeId] = vwapResults;
    }),
  );

  addTMNSymbols(vwapResultsByExchange, USDTPrice);

  const finalReturns = calculateFinalReturnsFromOpenPositions(
    openPositions,
    vwapResultsByExchange,
    returnTypeOnClose,
    USDTPrice,
  );

  await processPositionsConcurrently(
    finalReturns,
    exchanges,
    closeMinMarginPercent,
    orderTypeOnClose,
  );

  console.log('Finished monitoring open positions.');
}

export function calculateFinalReturnsFromOpenPositions(
  openPositions,
  vwapResultsByExchange,
  returnTypeOnClose,
  USDTPrice,
) {
  const { fees, slippage } = CONFIG;
  const finalReturns = [];
  for (const openPosition of openPositions) {
    const {
      id,
      symbol,
      buyExchange,
      sellExchange,
      entryBuyPrice,
      entrySellPrice,
    } = openPosition;

    const buyVWAP = vwapResultsByExchange[sellExchange][symbol]?.asks;
    const sellVWAP = vwapResultsByExchange[buyExchange][symbol]?.bids;

    if (!buyVWAP || !sellVWAP) continue;

    const buyFee = fees[sellExchange].taker;
    const sellFee = fees[buyExchange].taker;

    const netBuyPrice = buyVWAP * (1 + buyFee);
    const netSellPrice = sellVWAP * (1 - sellFee);

    const profitSellExhange = entrySellPrice - netBuyPrice;
    const profitBuyExhange = netSellPrice - entryBuyPrice;
    const profit = profitBuyExhange + profitSellExhange;

    const returnPercentage = (profit / entrySellPrice + entryBuyPrice) * 100;

    // Calculate slippage-adjusted prices
    const netSellPriceWithSlippage = netSellPrice * (1 - slippage);
    const netBuyPriceWithSlippage = netBuyPrice * (1 + slippage);

    // Profit with slippage
    const profitSellExchangeWithSlippage =
      entrySellPrice - netBuyPriceWithSlippage;
    const profitBuyExchangeWithSlippage =
      netSellPriceWithSlippage - entryBuyPrice;
    const profitWithSlippage =
      profitSellExchangeWithSlippage + profitBuyExchangeWithSlippage;

    const returnPercentageWithSlippage =
      profitWithSlippage / (entrySellPrice + entryBuyPrice);

    let selectedBuyPrice;
    let selectedSellPrice;
    switch (returnTypeOnClose) {
      case 'slip':
        selectedBuyPrice = netBuyPriceWithSlippage;
        selectedSellPrice = netSellPriceWithSlippage;
        break;

      default:
        selectedBuyPrice = netBuyPrice;
        selectedSellPrice = netSellPrice;
        break;
    }

    const selectedReturnPercentage =
      ((selectedSellPrice - selectedBuyPrice) /
        (selectedSellPrice + selectedBuyPrice)) *
      100;

    finalReturns.push({
      openPosition,
      id: openPosition?.id,
      symbol,
      buyExchange,
      sellExchange,
      selectedBuyPrice,
      selectedSellPrice,
      selectedReturnPercentage,
      netBuyPrice,
      netSellPrice,
      returnPercentage,
      netBuyPriceWithSlippage,
      netSellPriceWithSlippage,
      returnPercentageWithSlippage,
      tradeVolumeUSDT,
      USDTPrice,
    });
  }
  return finalReturns;
}

const processPositionsConcurrently = async (
  finalReturns,
  exchanges,
  closeMinMarginPercent,
  orderTypeOnClose,
) => {
  // Map finalReturns to an array of promises
  const promises = finalReturns.map(async finalReturn => {
    const {
      id,
      symbol,
      buyExchange,
      sellExchange,
      amount,
      entryBuyPrice,
      entrySellPrice,
      selectedReturnPercentage, // Added for margin check
    } = finalReturn;

    const position = {
      id,
      symbol,
      buyExchange,
      sellExchange,
      amount,
      entryBuyPrice,
      entrySellPrice,
    };

    try {
      console.log(
        `Position ${symbol} on ${buyExchange}/${sellExchange}: Current Return: ${selectedReturnPercentage.toFixed(
          2,
        )}%`,
      );

      // Skip if exit condition is not met
      if (selectedReturnPercentage < closeMinMarginPercent) {
        console.log(`Exit condition not met for ${symbol}. Skipping...`);
        return; // Skip further processing for this position
      }

      console.log(
        `Exit condition met for ${symbol} on ${buyExchange}/${sellExchange}. Closing position...`,
      );

      // Close the position
      await closePosition(exchanges, position, orderTypeOnClose);
    } catch (error) {
      console.error(
        `Error monitoring position ${symbol} on ${buyExchange}/${sellExchange}:`,
        error.message,
      );
    }
  });

  // Execute all promises concurrently and wait for completion
  const results = await Promise.allSettled(promises);

  // Log the results
  results.forEach((result, index) => {
    if (result.status === 'fulfilled') {
      console.log(
        `Successfully processed position ${finalReturns[index].symbol}`,
      );
    } else {
      console.error(
        `Failed to process position ${finalReturns[index].symbol}:`,
        result.reason,
      );
    }
  });
};
</codebase>

<nobitex_doc_cheatsheet>
Nobitex API Documentation Cheatsheet

This cheatsheet provides a quick reference guide to the Nobitex cryptocurrency exchange API.

Authentication
- Authorization: Token yourTOKENhereHEX0000000000
- All non-public APIs require a token sent in the Authorization header.
- Obtain your token from your Nobitex profile settings.
- Recommended method: Get token directly from the user panel.
- Automated token retrieval: Use the /auth/login API if necessary (requires handling security measures like 2FA and CAPTCHA).
- User Agent: Set the UserAgent header to TraderBot/XXXXX for better bot identification.

General Considerations
- Rate Limits: Each API has specific rate limits mentioned in its documentation.
- Error Handling: Implement proper error handling to manage unexpected situations and responses.
- API Changes: Regularly check for API updates and deprecated features.
- Troubleshooting: Ensure your code adheres to the documentation and use common debugging techniques.

Public Market Data
1. Order Book
   - GET /v3/orderbook/SYMBOL
   - Rate Limit: 300 requests/minute
   - Retrieves the order book for a specific market.
   - Parameters:
     - SYMBOL (string, required): Market symbol (e.g., BTCIRT, ETHUSDT).
   - Response:
     ```json
     {
         "status": "ok",
         "lastUpdate": 1644991756704,
         "lastTradePrice": "35650565900",
         "asks": [
             ["1476091000", "1.016"],
             ["1479700000", "0.2561"]
         ],
         "bids": [
             ["1470001120", "0.126571"],
             ["1470000000", "0.818994"]
         ]
     }
     ```
   - Get all order books:
     - GET /v3/orderbook/all
   - Deprecated order book (use v3 instead)
     - GET /v2/orderbook/SYMBOL

2. Depth Chart (Experimental)
   - GET /v2/depth/SYMBOL
   - Rate Limit: 300 requests/minute
   - Retrieves depth chart data for a specific market.
   - Parameters:
     - SYMBOL (string, required): Market symbol (e.g., BTCIRT).

3. Trades
   - GET /v2/trades/SYMBOL
   - Rate Limit: 60 requests/minute
   - Retrieves the list of recent trades for a specific market.
   - Parameters:
     - symbol (string, required): Market symbol (e.g., BTCIRT).

4. Market Statistics
   - GET /market/stats
   - Rate Limit: 20 requests/minute
   - Retrieves overall market statistics or filtered by source/destination currency.
   - Parameters:
     - srcCurrency (string, optional): Source currency (e.g., btc).
     - dstCurrency (string, optional): Destination currency (e.g., rls).

5. OHLC Statistics
   - GET /market/udf/history
   - Retrieves OHLC (Open, High, Low, Close) candlestick data.
   - Parameters:
     - symbol (string, required): Market symbol.
     - resolution (string, required): Timeframe per candle (e.g., 1, 5, 15, 30, 60, 180, 240, 360, 720, D, 2D, 3D).
     - to (int, required): End time (Unix timestamp in seconds).
     - from (int, optional): Start time (Unix timestamp in seconds).
     - countback (int, optional): Number of candles before the end time.
     - page (int, optional): Page number (default: 1).

6. Global Market Statistics
   - POST /market/global-stats
   - Rate Limit: 100 requests/10 minutes
   - Retrieves statistics from global markets (Kraken and Binance).

User Data
1. User Profile
   - GET /users/profile
   - Retrieves user profile information, bank cards, bank accounts, verification status, profile settings, and trade statistics.

2. Generate Blockchain Address
   - POST /users/wallets/generate-address
   - Rate Limit: 30 requests/hour
   - Generates a new blockchain address for a specific currency.
   - Parameters:
     - currency (string, required): Cryptocurrency (e.g., btc).

3. Add Bank Card
   - POST /users/cards-add
   - Rate Limit: 30 requests/30 minutes
   - Adds a new bank card to the user's profile.
   - Parameters:
     - number (string, required): Card number.
     - bank (string, required): Bank name.

4. Add Bank Account
   - POST /users/accounts-add
   - Rate Limit: 30 requests/30 minutes
   - Adds a new bank account to the user's profile.
   - Parameters:
     - number (string, required): Account number.
     - shaba (string, required): IBAN number.
     - bank (string, required): Bank name.

5. User Limitations
   - GET /users/limitations
   - Retrieves the user's limitations on withdrawals, deposits, and trades based on their verification level.

6. Wallet List
   - GET /users/wallets/list
   - Rate Limit: 20 requests/2 minutes
   - Retrieves a list of the user's wallets.

7. Selected Wallet List
   - GET /v2/wallets
   - Rate Limit: 15 requests/minute
   - Parameters:
     - currencies (string, optional): Comma-separated list of currencies (e.g., rls,btc).
     - type (string, optional): Wallet type ('spot' or 'margin', default: 'spot').
   - Retrieves a list of user's wallets for selected currencies.

8. Wallet Balance
   - POST /users/wallets/balance
   - Rate Limit: 60 requests/2 minutes
   - Retrieves the balance of a specific wallet.
   - Parameters:
     - currency (string, required): Currency (e.g., ltc).

9. Transactions List
   - GET /users/wallets/transactions/list
   - Rate Limit: 60 requests/2 minutes
   - Retrieves a list of transactions for a specific wallet.
   - Parameters:
     - wallet (int, required): Wallet ID.

10. Deposits List
    - GET /users/wallets/deposits/list
    - Rate Limit: 60 requests/2 minutes
    - Retrieves a list of deposits for a specific wallet.
    - Parameters:
      - wallet (string, required): Wallet ID.

11. Favorite Markets
    - GET /users/markets/favorite: Retrieves the user's favorite markets.
    - POST /users/markets/favorite: Adds markets to the user's favorite list.
      - Parameters:
        - market (string, required): Comma-separated list of market symbols.
    - DELETE /users/markets/favorite: Removes a market from the user's favorite list or removes all.
      - Parameters:
         - market (string, required): Market symbol or "All".

Spot Market Trading
1. Add Order
   - POST /market/orders/add
   - Rate Limit: 300 requests/10 minutes (shared limit)
   - Places a new order on the spot market.
   - Parameters:
     - type (string, required): Order type ('buy' or 'sell').
     - execution (string, required): Execution type ('limit', 'market', 'stop_market', 'stop_limit').
     - srcCurrency (string, required): Source currency.
     - dstCurrency (string, required): Destination currency.
     - amount (monetary, required): Order amount.
     - price (monetary, required): Order price (not required for market orders if you set price range).
     - stopPrice (monetary, required for stop orders): Stop price.
     - mode (string, required for OCO orders): 'oco'.
     - stopLimitPrice (monetary, required for OCO orders): Limit price for the stop-limit order in OCO.
     - clientOrderId (string, optional): Client-assigned order ID (up to 32 characters, unique among open/active/inactive orders).
   - Response:
        ```json
        {
        "status": "ok",
        "order": {
            "type": "sell",
            "srcCurrency": "Bitcoin",
            "dstCurrency": "ریال",
            "price": "520000000",
            "amount": "0.6",
            "totalPrice": "312000000.0",
            "matchedAmount": 0,
            "unmatchedAmount": "0.6",
            "id": 25,
            "status": "Active",
            "partial": false,
            "fee": 0,
            "created_at": "2018-11-28T11:36:13.592827+00:00",
            "clientOrderId": "order1"
        }
        }
        ```
2. Order Status
   - POST /market/orders/status
   - Rate Limit: 300 requests/minute
   - Retrieves the status of a specific order.
   - Parameters:
     - id (int, optional): Order ID.
     - clientOrderId (string, optional): Client-assigned order ID.

3. Order List
   - GET /market/orders/list
   - Rate Limit: 30 requests/minute
   - Retrieves a list of the user's orders.
   - Parameters:
     - status (string, optional): Order status ('open', 'done', 'close', 'all').
     - type (string, optional): Order type ('buy', 'sell').
     - execution (string, optional): Execution type.
     - tradeType (string, optional): Trade type ('spot', 'margin').
     - srcCurrency (string, optional): Source currency.
     - dstCurrency (string, optional): Destination currency.
     - details (int, optional): Level of detail in the response (1 or 2).
     - fromId (int, optional): Minimum order ID.
     - order (string, optional): Sorting order ('id', 'created_at', 'price', '-id', '-created_at', '-price').

4. Update Order Status
   - POST /market/orders/update-status
   - Rate Limit: 90 requests/minute
   - Changes the status of an order (cancel or activate).
   - Parameters:
     - order (int, optional): Order ID.
     - clientOrderId (string, optional): Client-assigned order ID.
     - status (string, required): New status ('canceled').

5. Cancel Multiple Orders
   - POST /market/orders/cancel-old
   - Rate Limit: 30 requests/minute
   - Cancels multiple active orders based on specified criteria.
   - Parameters:
     - hours (float, optional): Cancel orders older than this number of hours.
     - execution (string, optional): Execution type.
     - tradeType (string, optional): Trade type.
     - srcCurrency (string, optional): Source currency.
     - dstCurrency (string, optional): Destination currency.

6. User Trades List
   - GET /market/trades/list
   - Rate Limit: 30 requests/minute
   - Retrieves a list of the user's trades within the last 3 days.
   - Parameters:
     - srcCurrency (string, optional): Source currency.
     - dstCurrency (string, optional): Destination currency.
     - fromId (int, optional): Minimum trade ID.

Margin Market Trading
1. Margin Markets List
   - GET /margin/markets/list
   - Retrieves a list of supported margin markets.

2. Active Liquidity Pools
   - GET /liquidity-pools/list
   - Rate Limit: 12 requests/minute
   - Retrieves the capacity of active liquidity pools.

3. Transfer to Margin Wallet
   - POST /wallets/transfer
   - Rate Limit: 10 requests/minute
   - Transfers funds between spot and margin wallets.
   - Parameters:
     - currency (string, required): Currency.
     - amount (monetary, required): Amount to transfer.
     - src (string, required): Source wallet type ('spot' or 'margin').
     - dst (string, required): Destination wallet type ('spot' or 'margin').

4. Margin Delegation Limit
   - GET /margin/delegation-limit
   - Rate Limit: 12 requests/minute
   - Retrieves the user's margin delegation limit.
   - Parameters:
     - currency (string, required): Cryptocurrency.

5. Add Margin Order
   - POST /margin/orders/add
   - Rate Limit: 300 requests/10 minutes
   - Places a new order on the margin market.
   - Parameters:
      - execution (string, required): Execution type ('limit', 'market', 'stop_limit', 'stop_market')
      - srcCurrency (string, required): Source currency
      - dstCurrency (string, required): Destination currency
      - type (string, required): Order type ('buy' or 'sell')
      - leverage (monetary, required): Leverage
      - amount (monetary, required): Order amount
      - price (monetary, required): Order price
      - stopPrice (monetary, optional): Stop price for stop orders
      - mode (string, required for OCO orders): 'oco'
      - stopLimitPrice (monetary, required for OCO): Stop limit price for OCO
   - Response:
        ```json
        {
          "status": "ok",
          "order": {
            "id": 25,
            "type": "sell",
            "execution": "Limit",
            "tradeType": "Margin",
            "srcCurrency": "btc",
            "dstCurrency": "rls",
            "price": "6400000000",
            "amount": "0.01",
            "status": "Active",
            "totalPrice": "0",
            "totalOrderPrice": "64000000",
            "matchedAmount": 0,
            "unmatchedAmount": "0.01",
            "leverage": "2",
            "side": "open",
            "partial": false,
            "fee": 0,
            "created_at": "2022-10-20T11:36:13.592827+00:00",
            "averagePrice": "0"
          }
        }
        ```

6. Positions List
   - GET /positions/list
   - Rate Limit: 30 requests/minute
   - Retrieves a list of open and past positions.
   - Parameters:
     - srcCurrency (string, optional): Source currency.
     - dstCurrency (string, optional): Destination currency.
     - status (string, optional): Position status ('active' or 'past').

7. Position Status
   - GET /positions/:positionId:/status
   - Rate Limit: 100 requests/10 minutes (shared limit)
   - Retrieves the status of a specific position.
   - Parameters:
     - :positionId: (url-param, required): Position ID.

8. Close Position
   - POST /positions/:positionId:/close
   - Rate Limit: 300 requests/10 minutes
   - Closes a position by placing an order in the opposite direction.
   - Parameters:
     - :positionId: (url-param, required): Position ID.
     - execution (string, required): Execution type.
     - amount (monetary, required): Order amount.
     - price (monetary, required): Order price.
     - stopPrice (monetary, optional): Stop price for stop orders.
     - mode (string, required for OCO): 'oco'
     - stopLimitPrice (monetary, required for OCO): Stop limit price for OCO

9. Edit Position Collateral
   - POST /positions/:positionId:/edit-collateral
   - Rate Limit: 60 requests/minute
   - Modifies the collateral of an open position.
   - Parameters:
     - :positionId: (url-param, required): Position ID.
     - collateral (monetary, required): New collateral amount.

Withdrawals
1. Add Withdrawal Request
   - POST /users/wallets/withdraw
   - Rate Limit: 10 requests/3 minutes
   - Creates a new withdrawal request.
   - Parameters:
     - wallet (int, required): Wallet ID.
     - network (string, optional): Transfer network.
     - invoice (string, optional): Invoice (required for BTCLN).
     - amount (monetary, optional): Amount (required without invoice).
     - address (string, optional): Destination address (required without invoice).
     - explanations (string, optional): Explanations.
     - noTag (boolean, optional): No tag (default: false).
     - tag (string, optional): Transfer tag.

2. Confirm Withdrawal Request
   - POST /users/wallets/withdraw-confirm
   - Rate Limit: 30 requests/hour
   - Confirms a withdrawal request.
   - Parameters:
     - withdraw (int, required): Withdrawal request ID.
     - otp (int, required depending on the destination address): One-time password.

3. Withdrawals List
   - GET /users/wallets/withdraws/list
   - Rate Limit: 60 requests/2 minutes
   - Retrieves a list of recent withdrawals.
   - Parameters:
     - wallet (string, optional): Wallet ID.

4. Withdrawal Status
   - GET /withdraws/WITHDRAW
   - Rate Limit: 60 requests/2 minutes
   - Retrieves the status of a specific withdrawal request.
   - Parameters:
     - WITHDRAW (int, required): Withdrawal request ID.

Websocket (Experimental)
- URL: wss://wss.nobitex.ir/connection/websocket
- Rate Limit: 100 connections/IP
- No token required.
- SDKs: centrifuge-js, centrifuge-python, centrifuge-java, centrifuge-go, centrifuge-swift, centrifuge-dart, centrifuge-csharp.
- Keep-alive: Server sends ping messages, client must respond with pong within 25 seconds.
- Multiple channels: Subscribe to multiple channels using a single client.
- Order book stream:
  - Channel pattern: public:orderbook-* (e.g., public:orderbook-BTCIRT).
  - Use { delta: 'fossil' } for bandwidth optimization (requires Fossil algorithm implementation if not using official SDKs).

Address Book and Whitelist Mode
1. Address Book List
   - GET /address_book
   - Rate Limit: 20 requests/minute
   - Retrieves the user's address book.
   - Parameters:
     - network (string, optional): Filter by network.

2. Add Address
   - POST /address_book
   - Rate Limit: 6 requests/minute
   - Adds a new address to the address book.
   - Parameters:
     - title (string, required): Address title.
     - network (string, required): Network.
     - address (string, required): Address.
     - tag (string, required for tag-mandatory networks): Tag.
     - otpCode (string, required): Email and SMS verification code.
     - tfaCode (string, required): Two-factor authentication code.

3. Delete Address
   - DELETE /address_book/<address_id>/delete
   - Rate Limit: 6 requests/minute
   - Deletes an address from the address book.

4. Activate Whitelist Mode
   - POST /address_book/whitelist/activate
   - Rate Limit: 6 requests/minute
   - Activates whitelist mode, restricting withdrawals to addresses in the address book.

5. Deactivate Whitelist Mode
   - POST /address_book/whitelist/deactivate
   - Rate Limit: 6 requests/minute
   - Deactivates whitelist mode.
   - Parameters:
     - otpCode (string, required): Email and SMS verification code.
     - tfaCode (string, required): Two-factor authentication code.

Security
1. Login History
   - GET /users/login-attempts
   - Retrieves the user's login history.

2. Emergency Cancel Activation
   - GET /security/emergency-cancel/activate
   - Activates emergency cancellation of withdrawal requests.

3. Anti-Phishing Code
   - POST /security/anti-phishing: Creates an anti-phishing code.
   - Parameters:
        - code (string, required): Anti-phishing code.
        - otpCode (number, required): OTP code.
   - GET /security/anti-phishing: Retrieves the anti-phishing code.

Referral Program
1. Referral Links List
   - GET /users/referral/links-list
   - Rate Limit: 50 requests/10 minutes
   - Retrieves a list of the user's referral codes.

2. Add Referral Link
   - POST /users/referral/links-add
   - Rate Limit: 5 requests/minute
   - Creates a new referral code.
   - Parameters:
     - friendShare (int, optional): Referral commission share for the invited friend (default: 0).

3. Referral Status
   - GET /users/referral/referral-status
   - Rate Limit: 50 requests/10 minutes
   - Checks if the user was referred by another user.

4. Set Referrer
   - POST /users/referral/set-referrer
   - Rate Limit: 50 requests/10 minutes
   - Sets the referrer for the user (within 24 hours of registration).
   - Parameters:
     - referrerCode (string, required): Referrer's referral code.

Authentication
1. Login - Get Token
   - POST /auth/login/
   - Rate Limit: 30 requests/10 minutes
   - Retrieves an authentication token.
   - Parameters:
     - username (string, required): User's email.
     - password (string, required): User's password.
     - remember (string, optional): 'yes' for a long-term token (30 days), 'no' for a short-term token (4 hours).
     - captcha (string, required): CAPTCHA (use 'api' for requests from Iranian IPs).
     - X-TOTP (header, required if 2FA is enabled): TOTP code.

2. Logout - Invalidate Token
   - POST /auth/logout/
   - Invalidates the current authentication token.

Profit and Loss
1. Last Week Daily Profit
   - POST /users/portfolio/last-week-daily-profit
   - Rate Limit: 10 requests/3 minutes
   - Retrieves daily profit/loss data for the last week.

2. Last Week Daily Total Profit
   - POST /users/portfolio/last-week-daily-total-profit
   - Rate Limit: 10 requests/3 minutes
   - Retrieves total profit/loss data for the last week, aggregated daily.

3. Last Month Total Profit
   - POST /users/portfolio/last-month-total-profit
   - Rate Limit: 10 requests/3 minutes
   - Retrieves total profit/loss data for the last month.

Other
1. System Options
   - GET /v2/options
   - Retrieves system settings, including active cryptocurrencies, minimum order amounts, fee tiers, withdrawal limits, and other useful information.
   - No parameters.

Important Notes
- Error Codes: Refer to the "Error Codes" section in the documentation for each API endpoint to understand specific error messages.
- Monetary Values: Send monetary values as strings to maintain precision.
- Pagination: Use the page and pageSize parameters for paginated results.
- Time Filter: Use the from and to parameters for filtering by date.
- Shared Rate Limit: Be mindful of the shared rate limit for order placement APIs.
- Pro Mode: Use the pro=yes parameter to bypass certain restrictions if you understand the implications.
- Test Environment: Utilize the Nobitex test environment (https://testnet.nobitex.ir, API: https://testnetapi.nobitex.ir) for development and testing.
- Unix Time: Understand the Unix time format used for timestamps.
- Postman Collection: Use the provided Postman collection for code samples in various programming languages.
- API Documentation: Always refer to the official Nobitex API documentation for the most up-to-date information.
</nobitex_doc_cheatsheet>

<task>
Your task is to:
1. Define the two custom exchanges as subclasses of CCXT's `BaseExchange` or relevant classes.
2. Implement the necessary methods and attributes for these exchanges, such as:
   - Symbol unification.
   - Fetching market data, order book, and trades.
   - Placing and managing orders.
   - Error handling and retry mechanisms.
3. Ensure all code adheres to CCXT's documentation, conventions, and best practices.
</task>

<requirements>
1. Your solution **must** be based on CCXT's official documentation and expert practices.
2. Carefully analyze the provided codebase to ensure your additions are compatible and cohesive.
3. The implementation **must** be error-free and production-ready, covering:
   - Proper input validation.
   - Handling edge cases.
   - Comprehensive coverage of required features.
4. Clearly explain your thought process for each part of the implementation.
5. Include comments in the code for clarity and maintainability.
</requirements>

<note>
Think deeply about the design and implementation. Ensure robustness, correctness, and compatibility. 
Focus on delivering a high-quality solution that integrates seamlessly with the provided codebase.
</note>

</prompt>

