Directory Structure:
-------------------
/ 
├── close/
│   └── closePosition.js
├── fetch/
│   ├── fetchOrderBooks.js
│   └── fetchPrices.js
├── monitoring/
│   └── monitoring.js
├── opportunitiesAndFinalReturns/
│   └── opportunitiesAndFinalReturns.js
├── orderCreation/
│   ├── orderCreation.js
│   └── orderExchangeCreation.js
├── transforms/
│   ├── originalizations.js
│   └── standardizations.js
├── utils/
│   ├── addTMNSymbols.js
│   ├── calculateTMNPrice.js
│   ├── database.js
│   ├── splitSymbols.js
│   └── storeOpenPositions.js
├── VWAP/
│   └── VWAP.js
├── .gitignore
├── .prettierrc
├── config.js
├── dump.py
├── exclude.txt
├── index.js
├── open_positions.db
├── output.txt
└── package.json

File Contents:
--------------
File: ./index.js
--------------------------------------------------
Content of ./index.js:
// Import required libraries

import ccxt from 'ccxt';
import dotenv from 'dotenv';
import { standardizeSpecialCoinPrices } from './transforms/standardizations.js';
import { fetchAllPrices } from './fetch/fetchPrices.js';
import {
  calculateFinalReturns,
  findArbitrageOpportunities,
} from './opportunitiesAndFinalReturns/opportunitiesAndFinalReturns.js';
import { calculateTMNPrice } from './utils/calculateTMNPrice.js';
import { CONFIG } from './config.js';
import { createOrder } from './orderCreation/orderCreation.js';
import { monitorOpenPositions } from './monitoring/monitoring.js';

dotenv.config();

const {
  exchangesToUse,
  exchangeParams,
  customExchanges,
  minMarginPercent,
  returnTypeOnOpen,
  orderTypeOnOpen,
  refreshIntervalMs,
} = CONFIG;
// Initialize exchanges
const exchanges = {};

// Initialize ccxt exchanges
for (const id of exchangesToUse) {
  if (ccxt.exchanges.includes(id) && !customExchanges.includes(id)) {
    exchanges[id] = new ccxt[id]({
      apiKey: exchangeParams[id]?.apiKey,
      secret: exchangeParams[id]?.secret,
      options: exchangeParams[id]?.options,
      enableRateLimit: true,
    });
  } else if (!customExchanges.includes(id)) {
    throw new Error(`Unsupported exchange: ${id}`);
  }
}

// Main Execution Function
async function main() {
  while (true) {
    try {
      const allPrices = await fetchAllPrices(exchanges);

      console.log('COMPLETE: Price fetching\n');

      const nobitexUSDTPrice =
        (allPrices.nobitex['USDT/TMN'].ask +
          allPrices.nobitex['USDT/TMN'].bid) /
        2;
      const wallexUSDTPrice =
        (allPrices.wallex['USDT/TMN'].ask + allPrices.wallex['USDT/TMN'].bid) /
        2;
      const USDTPrice = (nobitexUSDTPrice + wallexUSDTPrice) / 2;

      standardizeSpecialCoinPrices(allPrices);
      calculateTMNPrice(allPrices, USDTPrice);

      const opportunities = findArbitrageOpportunities(allPrices);

      let finalReturns = await calculateFinalReturns(
        opportunities,
        exchanges,
        USDTPrice,
        returnTypeOnOpen,
      );

      finalReturns = finalReturns
        .filter(
          fr =>
            fr.selectedReturnPercentage > minMarginPercent &&
            fr.selectedReturnPercentage < 4,
        )
        .sort(
          (a, b) => b.selectedReturnPercentage - a.selectedReturnPercentage,
        );

      if (finalReturns?.length) {
        const order = finalReturns[0];

        console.log('hi');
        await createOrder(exchanges, order, orderTypeOnOpen);
      }

      if (!finalReturns?.length) {
        console.log('No profitable position available!');
      }

      for (const finalReturn of finalReturns.slice(0, 3)) {
        console.log(
          `Position: Long ${finalReturn.symbol} on ${
            finalReturn.buyExchange
          } at ${finalReturn.selectedBuyPrice.toFixed(6)}, Short on ${
            finalReturn.sellExchange
          } at ${finalReturn.selectedSellPrice.toFixed(
            6,
          )}, Expected Return: ${finalReturn.selectedReturnPercentage.toFixed(
            2,
          )}%`,
        );
      }

      // Monitor open positions
      await monitorOpenPositions(exchanges, USDTPrice);
      console.log('-----------------------------\n\n');
      if (finalReturns?.length) break;
      // Wait before next iteration
      await new Promise(resolve => setTimeout(resolve, refreshIntervalMs));
    } catch (error) {
      console.error('An error occurred:', error.message);
      // Wait before next iteration in case of error
      await new Promise(resolve => setTimeout(resolve, refreshIntervalMs));
    }
  }
}

// Start the script
main();


File: ./config.js
--------------------------------------------------
Content of ./config.js:
// Configuration
export const CONFIG = {
  minMarginPercent: 0.5, // Minimum margin percentage to consider
  minVolumeUSD: 10, // Minimum trade volume in USDT
  returnTypeOnOpen: 'spread', // enum: [null, 'slip', 'spread']]
  returnTypeOnClose: null, // enum: [null, 'slip']
  closeMinMarginPercent: 0.4,
  orderTypeOnOpen: 'limit',
  orderTypeOnClose: 'limit',
  leverage: 1, // Leverage for positions
  refreshIntervalMs: 10000, // Interval to refresh data in milliseconds
  fees: {
    coinex: { maker: 0.0015, taker: 0.0015 },
    nobitex: { maker: 0.0015, taker: 0.0015 },
    wallex: { maker: 0.001, taker: 0.001 },
  },
  slippage: 0.0005,
  exchangesToUse: ['coinex', 'nobitex', 'wallex'],
  customExchanges: ['nobitex', 'wallex'],
  coinsToConsider: null, // null means all coins
  coinsToIgnore: ['OMG', 'X', 'BCH'],
  specialCoinStandardizations: {
    nobitex: [
      {
        originalBase: '100K_FLOKI',
        standardBase: 'FLOKI',
        correctionFactor: 1e-5,
      },
      {
        originalBase: '1B_BABYDOGE',
        standardBase: 'BABYDOGE',
        correctionFactor: 1e-9,
      },
      {
        originalBase: '1M_BTT',
        standardBase: 'BTT',
        correctionFactor: 1e-6,
      },
      {
        originalBase: '1M_NFT',
        standardBase: 'NFT',
        correctionFactor: 1e-6,
      },
      {
        originalBase: '1M_PEPE',
        standardBase: 'PEPE',
        correctionFactor: 1e-6,
      },
      {
        originalBase: 'SHIB',
        standardBase: 'SHIB',
        correctionFactor: 1e-3,
      },
    ],
    wallex: [
      {
        originalBase: '1BBABYDOGE',
        standardBase: 'BABYDOGE',
        correctionFactor: 1e-9,
      },
    ],
  },
  exchangeParams: {
    coinex: {
      apiKey: process.env.COINEX_API_KEY,
      secret: process.env.COINEX_SECRET_KEY,
      options: {
        defaultType: 'future',
      },
    },
    nobitex: {
      apiKey: process.env.NOBITEX_API_KEY,
      secret: process.env.NOBITEX_SECRET_KEY,
    },
    wallex: {
      apiKey: process.env.WALLEX_API_KEY,
      secret: process.env.WALLEX_SECRET_KEY,
    },
  },
  databaseName: './open_positions.db',
  orderTypeOnClose: 'limit', // 'market' or 'limit' - determines the order type used when closing positions
  limitOrderPriceMargin: 0.001, // 0.1% - The margin to add/subtract from the top bid/ask when placing limit orders
};


File: opportunitiesAndFinalReturns/opportunitiesAndFinalReturns.js
--------------------------------------------------
Content of opportunitiesAndFinalReturns/opportunitiesAndFinalReturns.js:
import NodeCache from 'node-cache';
import { CONFIG } from '../config.js';
import { getVWAPs } from '../VWAP/VWAP.js';
import { addTMNSymbols } from '../utils/addTMNSymbols.js';

const cache = new NodeCache({ stdTTL: 600 });

export function findArbitrageOpportunities(allPrices) {
  const { minMarginPercent, fees } = CONFIG;

  const opportunities = new Array(1000); // Preallocate space for opportunities
  let opportunityCount = 0;

  const exchanges = Object.keys(allPrices);
  const exchangeCount = exchanges.length;

  const feeMultipliers = new Map(
    exchanges.map(exchange => [
      exchange,
      {
        buy: 1 + fees[exchange].taker,
        sell: 1 - fees[exchange].taker,
      },
    ]),
  );

  for (let i = 0; i < exchangeCount - 1; i++) {
    const exchangeA = exchanges[i];
    const dataA = allPrices[exchangeA];

    for (let j = i + 1; j < exchangeCount; j++) {
      const exchangeB = exchanges[j];
      const dataB = allPrices[exchangeB];

      // Generate a unique cache key
      const cacheKey = `${exchangeA}-${exchangeB}`;

      // Retrieve or compute common bases
      let commonSymbols = cache.get(cacheKey);
      if (!commonSymbols) {
        const symbolA = new Set(Object.keys(dataA));
        const symbolB = new Set(Object.keys(dataB));
        commonSymbols = [...symbolA].filter(symbol => symbolB.has(symbol)); // Intersection
        cache.set(cacheKey, commonSymbols); // Cache the result
      }

      for (const symbol of commonSymbols) {
        const priceA = dataA[symbol];
        const priceB = dataB[symbol];

        // Get fee multipliers
        const feesA = feeMultipliers.get(exchangeA);
        const feesB = feeMultipliers.get(exchangeB);

        // Calculate prices with fees
        const buyPriceA = priceA.ask * feesA.buy;
        const sellPriceA = priceA.bid * feesA.sell;
        const buyPriceB = priceB.ask * feesB.buy;
        const sellPriceB = priceB.bid * feesB.sell;

        // Calculate margins and check arbitrage opportunities
        if (buyPriceA < sellPriceB) {
          const marginAB = ((sellPriceB - buyPriceA) / sellPriceB) * 100;
          if (marginAB >= minMarginPercent) {
            opportunities[opportunityCount++] = {
              symbol,
              buyExchange: exchangeA,
              sellExchange: exchangeB,
              buyPrice: buyPriceA,
              sellPrice: sellPriceB,
              margin: marginAB,
            };
          }
        } else if (buyPriceB < sellPriceA) {
          const marginBA = ((sellPriceA - buyPriceB) / sellPriceA) * 100;
          if (marginBA >= minMarginPercent) {
            opportunities[opportunityCount++] = {
              symbol,
              buyExchange: exchangeB,
              sellExchange: exchangeA,
              buyPrice: buyPriceB,
              sellPrice: sellPriceA,
              margin: marginBA,
            };
          }
        }
      }
    }
  }

  return opportunities
    .slice(0, opportunityCount)
    .sort((a, b) => b.margin - a.margin);
}

export async function calculateFinalReturns(
  opportunities,
  exchanges,
  USDTPrice,
  returnTypeOnOpen = null, // enum: [null, 'slip', 'spread']]
) {
  const { fees, leverage, minVolumeUSD, slippage } = CONFIG;

  const tradeVolumeUSDT = minVolumeUSD * leverage;

  const symbolsAndSidesByExchange = {};

  for (const opportunity of opportunities) {
    const { symbol, buyExchange, sellExchange } = opportunity;

    // Process buy side
    if (!symbolsAndSidesByExchange[buyExchange]) {
      symbolsAndSidesByExchange[buyExchange] = {};
    }
    if (!symbolsAndSidesByExchange[buyExchange][symbol]) {
      symbolsAndSidesByExchange[buyExchange][symbol] = new Set();
    }
    symbolsAndSidesByExchange[buyExchange][symbol].add('buy');

    // Process sell side
    if (!symbolsAndSidesByExchange[sellExchange]) {
      symbolsAndSidesByExchange[sellExchange] = {};
    }
    if (!symbolsAndSidesByExchange[sellExchange][symbol]) {
      symbolsAndSidesByExchange[sellExchange][symbol] = new Set();
    }
    symbolsAndSidesByExchange[sellExchange][symbol].add('sell');
  }

  // Fetch VWAPs for exchanges
  const vwapResultsByExchange = {};

  await Promise.all(
    Object.entries(symbolsAndSidesByExchange).map(
      async ([exchangeId, symbolsAndSides]) => {
        const vwapResults = await getVWAPs(
          exchanges,
          exchangeId,
          Object.keys(symbolsAndSides),
          tradeVolumeUSDT,
          USDTPrice,
        );
        vwapResultsByExchange[exchangeId] = vwapResults;
      },
    ),
  );
  console.log('COMPLETE: Order books fetched\n');
  addTMNSymbols(vwapResultsByExchange, USDTPrice);

  const finalReturns = calculateFinalReturnsFromOpportunities(
    opportunities,
    vwapResultsByExchange,
    returnTypeOnOpen,
  );

  return finalReturns;
}

export function calculateFinalReturnsFromOpportunities(
  opportunities,
  vwapResultsByExchange,
  returnTypeOnOpen,
) {
  const fees = CONFIG?.fees;
  const finalReturns = [];
  for (const opportunity of opportunities) {
    const { symbol, buyExchange, sellExchange } = opportunity;

    const spreadBuyExchange =
      vwapResultsByExchange[buyExchange][symbol]?.spread;
    const spreadSellExchange =
      vwapResultsByExchange[sellExchange][symbol]?.spread;

    const buyVWAP = vwapResultsByExchange[buyExchange][symbol]?.asks;
    const sellVWAP = vwapResultsByExchange[sellExchange][symbol]?.bids;
    if (!buyVWAP || !sellVWAP) continue;
    const buyFee = fees[buyExchange].taker;
    const sellFee = fees[sellExchange].taker;

    const netBuyPrice = buyVWAP * (1 + buyFee);
    const netSellPrice = sellVWAP * (1 - sellFee);

    const profit = netSellPrice - netBuyPrice;

    const totalEntryCost = netBuyPrice + netSellPrice;
    const returnPercentage = (profit / totalEntryCost) * 100;

    const netSellPriceWithSlippage = netSellPrice * (1 - slippage);
    const netBuyPriceWithSlippage = netBuyPrice * (1 + slippage);
    const profitWithSlippage =
      netSellPriceWithSlippage - netBuyPriceWithSlippage;
    const totalEntryCostWithSlippage =
      netSellPriceWithSlippage + netBuyPriceWithSlippage;
    const returnPercentageWithSlippage =
      (profitWithSlippage / totalEntryCostWithSlippage) * 100;

    const netSellPriceWithSlippageAndSpread =
      netSellPriceWithSlippage - spreadBuyExchange;
    const netBuyPriceWithSlippageAndSpread =
      netBuyPriceWithSlippage + spreadSellExchange;
    const profitWithSlippageAndSpread =
      netSellPriceWithSlippageAndSpread - netBuyPriceWithSlippageAndSpread;
    const totalEntryCostWithSlippageAndSpread =
      netSellPriceWithSlippageAndSpread + netBuyPriceWithSlippageAndSpread;
    const returnPercentageWithSlippageAndSpread =
      (profitWithSlippageAndSpread / totalEntryCostWithSlippageAndSpread) * 100;

    let selectedBuyPrice;
    let selectedSellPrice;
    switch (returnTypeOnOpen) {
      case 'slip':
        selectedBuyPrice = netBuyPriceWithSlippage;
        selectedSellPrice = netSellPriceWithSlippage;
        break;

      case 'spread':
        selectedBuyPrice = netBuyPriceWithSlippageAndSpread;
        selectedSellPrice = netSellPriceWithSlippageAndSpread;
        break;

      default:
        selectedBuyPrice = netBuyPrice;
        selectedSellPrice = netSellPrice;
        break;
    }

    const selectedReturnPercentage =
      ((selectedSellPrice - selectedBuyPrice) / selectedSellPrice) * 100;

    finalReturns.push({
      opportunity,
      symbol,
      buyExchange,
      sellExchange,
      selectedBuyPrice,
      selectedSellPrice,
      selectedReturnPercentage,
      netBuyPrice,
      netSellPrice,
      returnPercentage,
      netBuyPriceWithSlippage,
      netSellPriceWithSlippage,
      returnPercentageWithSlippage,
      netBuyPriceWithSlippageAndSpread,
      netSellPriceWithSlippageAndSpread,
      returnPercentageWithSlippageAndSpread,
      tradeVolumeUSDT,
      USDTPrice,
    });
  }
}


File: close/closePosition.js
--------------------------------------------------
Content of close/closePosition.js:
import { createOrder } from '../orderCreation/orderCreation.js';
import {
  moveToClosedPositions,
  updateOpenPosition,
} from '../utils/database.js';

export async function closePosition(
  exchanges,
  {
    id,
    symbol,
    buyExchange,
    sellExchange,
    amount,
    selectedBuyPrice,
    selectedSellPrice,
    tradeVolumeUSDT,
    USDTPrice,
  },
  type,
) {
  console.log(
    `Initiating position closure for ${symbol} on ${buyExchange}/${sellExchange}`,
  );

  try {
    await updateOpenPosition(id, { status: 'closing' });
    //! check prices both selected and net
    const closingOrderResult = await createOrder(
      exchanges,
      {
        symbol,
        buyExchange: sellExchange,
        sellExchange: buyExchange,
        selectedBuyPrice: selectedBuyPrice,
        selectedSellPrice: selectedSellPrice,
        tradeVolumeUSDT,
        netBuyPrice,
        netSellPrice,
        USDTPrice,
        amount,
      },
      type,
      true,
    );

    if (!closingOrderResult) {
      throw new Error('Failed to execute closing orders');
    }

    await moveToClosedPositions(id, {
      closeBuyPrice: selectedBuyPrice,
      closeSellPrice: selectedSellPrice,
    });

    const closeTime = new Date().toISOString();
    console.log(
      `Successfully closed position for ${symbol}:`,
      `\n- Buy Exchange: ${buyExchange}`,
      `\n- Sell Exchange: ${sellExchange}`,
      `\n- Amount: ${amount}`,
      `\n- Close Time: ${closeTime}`,
    );

    return {
      success: true,
      closeTime,
      closingOrders: closingOrderResult,
      message: 'Position closed successfully',
    };
  } catch (error) {
    await updateOpenPosition(id, { status: 'open' });

    console.error(
      `Failed to close position for ${symbol} on ${buyExchange}/${sellExchange}:`,
      error.message,
    );

    throw {
      success: false,
      error: error.message,
      details: {
        symbol,
        buyExchange,
        sellExchange,
        amount,
        failureTime: Date.now(),
      },
    };
  }
}


File: orderCreation/orderCreation.js
--------------------------------------------------
Content of orderCreation/orderCreation.js:
import { storeOpenPosition } from '../utils/storeOpenPositions.js';
import { createExchangeOrder } from './orderExchangeCreation.js';

// Main function
export async function createOrder(
  exchanges,
  order,
  type = 'limit',
  isClose = false,
) {
  const {
    symbol,
    buyExchange,
    sellExchange,
    selectedBuyPrice,
    selectedSellPrice,
    tradeVolumeUSDT,
    netBuyPrice,
    netSellPrice,
    USDTPrice,
  } = order;

  const amountToTrade = {
    USDT: tradeVolumeUSDT / ((netBuyPrice + netSellPrice) / 2),
    TMN: (tradeVolumeUSDT * USDTPrice) / ((netBuyPrice + netSellPrice) / 2),
  };

  console.log(
    `Placing orders: Buy ${amountToTrade[symbol.split('/')[0]].toFixed(
      6,
    )} ${symbol} on ${buyExchange}, Sell on ${sellExchange}`,
  );

  let buyOrder, sellOrder;

  const [buyResult, sellResult] = await Promise.allSettled([
    createExchangeOrder(
      buyExchange,
      symbol,
      type,
      'buy',
      amountToTrade,
      selectedBuyPrice,
      exchanges,
      USDTPrice,
    ),
    createExchangeOrder(
      sellExchange,
      symbol,
      type,
      'sell',
      amountToTrade,
      selectedSellPrice,
      exchanges,
      USDTPrice,
    ),
  ]);

  if (buyResult.status === 'fulfilled') {
    buyOrder = buyResult.value;
  } else {
    console.error('Buy order failed:', buyResult.reason);
  }

  if (sellResult.status === 'fulfilled') {
    sellOrder = sellResult.value;
  } else {
    console.error('Sell order failed:', sellResult.reason);
  }
  // Store Open Position if successful
  if (buyOrder && sellOrder && !isClose) {
    storeOpenPosition({
      symbol,
      buyExchange,
      sellExchange,
      amount: amountToTrade[symbol.split('/')[1]],
      entryBuyPrice: buyOrder.average,
      entrySellPrice: sellOrder.average,
    });
  }
}


File: orderCreation/orderExchangeCreation.js
--------------------------------------------------
Content of orderCreation/orderExchangeCreation.js:
import axios from 'axios';
import { CONFIG } from '../config.js';
import { originalizeSpecialCoinOrder } from '../transforms/originalizations.js';

export async function createExchangeOrder(
  exchangeId,
  symbol,
  type,
  side,
  amount,
  price,
  exchanges,
  USDTPrice,
) {
  switch (exchangeId) {
    case 'nobitex':
      return createNobitexOrder(symbol, type, side, amount, price);

    case 'wallex':
      return createWallexOrder(symbol, type, side, amount, price);

    default:
      let convertedValues;
      if (symbol.endsWith('/TMN')) {
        convertedValues = convertTMNOrderToUSDT(symbol, price, USDTPrice);
      }
      const convertedSymbol = convertedValues?.convertedSymbol || symbol;
      const convertedPrice = convertedValues?.convertedPrice || price;

      return exchanges[exchangeId].createOrder(
        convertedSymbol,
        type,
        side,
        amount.USDT,
        convertedPrice,
      );
  }
}

const { exchangeParams } = CONFIG;
const apiKey = exchangeParams.nobitex.apiKey;

async function createNobitexOrder(symbol, type, side, amount, price) {
  // Nobitex expects the symbol in a specific format (e.g., 'BTCIRT')
  const [base, quote] = symbol.split('/');

  let {
    transformedBase: nobitexBase,
    transformedAmount: nobitexAmount,
    transformedPrice: nobitexPrice,
  } = originalizeSpecialCoinOrder('nobitex', base, amount[quote], price);

  const url = 'https://api.nobitex.ir/market/orders/add';
  const headers = {
    Authorization: `Token ${apiKey}`,
    'Content-Type': 'application/json',
    UserAgent: `TraderBot/19977`,
  };
  const dstCurrency = quote === 'TMN' ? 'rls' : 'usdt';
  let srcCurrency = nobitexBase.toLowerCase();
  nobitexPrice = quote === 'TMN' ? nobitexPrice * 10 : nobitexPrice;

  let body = {
    type: side,
    execution: type,
    srcCurrency,
    dstCurrency,
    amount: nobitexAmount.toString(),
    price: nobitexPrice.toString(),
  };

  try {
    const response = await axios.post(url, body, { headers });
    if (response.data.status === 'failed') {
      throw new Error(
        `Nobitex order creation failed: ${JSON.stringify(response.data)}`,
      );
    }
    console.log(
      `Nobitex order created successfully: ${JSON.stringify(response.data)}`,
    );
    return response.data;
  } catch (error) {
    console.error(
      `Error creating Nobitex order: ${
        error.response ? JSON.stringify(error.response.data) : error.message
      }`,
    );
    throw error;
  }
}

async function createWallexOrder(symbol, type, side, amount, price) {
  const { exchangeParams } = CONFIG;
  const apiKey = exchangeParams.wallex.apiKey;

  const [base, quote] = symbol.split('/');

  let {
    transformedBase: wallexBase,
    transformedAmount: wallexAmount,
    transformedPrice: wallexPrice,
  } = originalizeSpecialCoinOrder('wallex', base, amount[quote], price);

  // Wallex expects the symbol in a specific format (e.g., 'BTCUSDT')
  const wallexSymbol = wallexBase + quote;

  const url = 'https://api.wallex.ir/v1/order/create';
  const timestamp = Date.now();

  const body = {
    symbol: wallexSymbol,
    type,
    side,
    quantity: wallexAmount.toString(),
    price: wallexPrice.toString(),
    timestamp,
  };

  const headers = {
    'x-api-key': apiKey,
    'Content-Type': 'application/json',
  };

  try {
    const response = await axios.post(url, body, { headers });

    if (response.data.code !== 201 && response.data.code !== 200) {
      throw new Error(
        `Wallex order creation failed: ${JSON.stringify(response.data)}`,
      );
    }

    console.log(
      `Wallex order created successfully: ${JSON.stringify(response.data)}`,
    );
    return response.data;
  } catch (error) {
    console.error(
      `Error creating Wallex order: ${
        error.response ? JSON.stringify(error.response.data) : error.message
      }`,
    );
    throw error;
  }
}

function convertTMNOrderToUSDT(symbol, price, USDTPrice) {
  const convertedSymbol = symbol.replace('/TMN', '/USDT');
  const convertedPrice = price / USDTPrice;

  return { convertedSymbol, convertedPrice };
}


File: utils/database.js
--------------------------------------------------
Content of utils/database.js:
import sqlite3 from 'sqlite3';
import { CONFIG } from '../config.js';

const { databaseName } = CONFIG;
const db = new sqlite3.Database(databaseName, err => {
  if (err) {
    console.error('Error opening database:', err.message);
  } else {
    console.log('Connected to the SQLite database.');
  }
});
// Extend the existing database setup
db.serialize(() => {
  db.run(
    `
        CREATE TABLE IF NOT EXISTS positions (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          symbol TEXT NOT NULL,
          buyExchange TEXT NOT NULL,
          sellExchange TEXT NOT NULL,
          amount REAL NOT NULL,
          entryBuyPrice REAL NOT NULL,
          entrySellPrice REAL NOT NULL,
          timestamp INTEGER NOT NULL,
          status TEXT DEFAULT 'open'
        )
      `,
    err => {
      if (err) {
        console.error('Error creating positions table:', err.message);
      } else {
        console.log('Positions table created or already exists.');
      }
    },
  );

  db.run(
    `CREATE TABLE IF NOT EXISTS closed_positions (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        symbol TEXT NOT NULL,
        buyExchange TEXT NOT NULL,
        sellExchange TEXT NOT NULL,
        amount REAL NOT NULL,
        entryBuyPrice REAL NOT NULL,
        entrySellPrice REAL NOT NULL,
        closeBuyPrice REAL NOT NULL,
        closeSellPrice REAL NOT NULL,
        timestamp INTEGER NOT NULL,
        closeTimestamp INTEGER NOT NULL
      )`,
    err => {
      if (err) {
        console.error('Error creating closed_positions table:', err.message);
      } else {
        console.log('Closed positions table created or already exists.');
      }
    },
  );
});

// Function to update an open position
function updateOpenPosition(id, updates) {
  return new Promise((resolve, reject) => {
    const fields = Object.keys(updates)
      .map(key => `${key} = ?`)
      .join(', ');
    const values = [...Object.values(updates), id];
    db.run(
      `UPDATE positions SET ${fields} WHERE id = ?`,
      values,
      function (err) {
        if (err) {
          console.error('Error updating position:', err.message);
          reject(err);
        } else if (this.changes === 0) {
          reject(new Error('No position found to update'));
        } else {
          console.log(`Position with ID ${id} updated.`);
          resolve();
        }
      },
    );
  });
}

// Function to move a position to the closed_positions table
function moveToClosedPositions(positionId, closingDetails) {
  return new Promise((resolve, reject) => {
    db.get(
      `SELECT * FROM positions WHERE id = ?`,
      [positionId],
      (err, position) => {
        if (err) {
          console.error('Error fetching position to close:', err.message);
          reject(err);
          return;
        }
        if (!position) {
          reject(new Error(`Position with ID ${positionId} not found.`));
          return;
        }

        const closeTimestamp = Date.now();
        db.run(
          `INSERT INTO closed_positions 
            (symbol, buyExchange, sellExchange, amount, entryBuyPrice, entrySellPrice, closeBuyPrice, closeSellPrice, timestamp, closeTimestamp)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
          [
            position.symbol,
            position.buyExchange,
            position.sellExchange,
            position.amount,
            position.entryBuyPrice,
            position.entrySellPrice,
            closingDetails.closeBuyPrice,
            closingDetails.closeSellPrice,
            position.timestamp,
            closeTimestamp,
          ],
          function (insertErr) {
            if (insertErr) {
              console.error(
                'Error moving position to closed_positions:',
                insertErr.message,
              );
              reject(insertErr);
              return;
            }

            // Delete from the open positions table after moving
            db.run(
              `DELETE FROM positions WHERE id = ?`,
              [positionId],
              function (deleteErr) {
                if (deleteErr) {
                  console.error(
                    'Error removing open position:',
                    deleteErr.message,
                  );
                  reject(deleteErr);
                  return;
                }
                console.log(
                  `Position with ID ${positionId} moved to closed_positions.`,
                );
                resolve();
              },
            );
          },
        );
      },
    );
  });
}

function storePosition(position) {
  return new Promise((resolve, reject) => {
    const {
      symbol,
      buyExchange,
      sellExchange,
      amount,
      entryBuyPrice,
      entrySellPrice,
    } = position;
    const timestamp = Date.now();
    db.run(
      `INSERT INTO positions (symbol, buyExchange, sellExchange, amount, entryBuyPrice, entrySellPrice, timestamp)
         VALUES (?, ?, ?, ?, ?, ?, ?)`,
      [
        symbol,
        buyExchange,
        sellExchange,
        amount,
        entryBuyPrice,
        entrySellPrice,
        timestamp,
      ],
      function (err) {
        if (err) {
          console.error('Error storing position:', err.message);
          reject(err);
        } else {
          console.log(`Position stored with ID: ${this.lastID}`);
          resolve(this.lastID);
        }
      },
    );
  });
}

function getOpenPositions() {
  return new Promise((resolve, reject) => {
    db.all(`SELECT * FROM positions`, [], (err, rows) => {
      if (err) {
        console.error('Error fetching open positions:', err.message);
        reject(err);
      } else {
        resolve(rows);
      }
    });
  });
}

function removePosition(positionId) {
  return new Promise((resolve, reject) => {
    db.run(`DELETE FROM positions WHERE id = ?`, positionId, function (err) {
      if (err) {
        console.error('Error removing position:', err.message);
        reject(err);
      } else {
        console.log(`Position with ID ${positionId} removed.`);
        resolve();
      }
    });
  });
}

// Close the database connection when the application exits
process.on('exit', () => {
  db.close(err => {
    if (err) {
      console.error('Error closing the database:', err.message);
    } else {
      console.log('Database connection closed.');
    }
  });
});

// Handle SIGINT (Ctrl+C) to gracefully close the database connection
process.on('SIGINT', () => {
  console.log('Closing database connection...');
  db.close(err => {
    if (err) {
      console.error('Error closing the database:', err.message);
    } else {
      console.log('Database connection closed.');
    }
  });
  process.exit();
});

// Export the new functions
export {
  storePosition,
  getOpenPositions,
  removePosition,
  updateOpenPosition,
  moveToClosedPositions,
};


File: utils/addTMNSymbols.js
--------------------------------------------------
Content of utils/addTMNSymbols.js:
import { CONFIG } from '../config.js';
import { splitSymbolsIntoQuoteAndBase } from './splitSymbols.js';

export function addTMNSymbols(VWAPsByExchange, USDTPrice) {
  const { customExchanges } = CONFIG;
  for (const exchangeId in VWAPsByExchange) {
    if (customExchanges.includes(exchangeId)) continue;

    const quotesMap = splitSymbolsIntoQuoteAndBase(null, exchangeId);

    if (quotesMap.USDT?.length) {
      for (const symbol in VWAPsByExchange[exchangeId]) {
        let TMNSymbol = symbol.replace('/USDT', '/TMN');
        VWAPsByExchange[exchangeId][TMNSymbol] = {};
        VWAPsByExchange[exchangeId][TMNSymbol].asks =
          VWAPsByExchange[exchangeId][symbol].asks * USDTPrice;
        VWAPsByExchange[exchangeId][TMNSymbol].bids =
          VWAPsByExchange[exchangeId][symbol].bids * USDTPrice;
        VWAPsByExchange[exchangeId][TMNSymbol].spread =
          VWAPsByExchange[exchangeId][symbol].spread * USDTPrice;
      }
    }
  }
  return;
}


File: utils/splitSymbols.js
--------------------------------------------------
Content of utils/splitSymbols.js:
import NodeCache from 'node-cache';

const baseCache = new NodeCache({
  stdTTL: 600, // cache expires after 10 minute
});
const quoteCache = new NodeCache({
  stdTTL: 600, // cache expires after 10 minute
});

export function splitSymbolsIntoBaseAndQuote(symbols, exchangeId) {
  const key = exchangeId;
  const cachedValue = baseCache.get(key);
  if (cachedValue) {
    return cachedValue;
  }

  const basesMap = {};
  for (const symbol of symbols) {
    const [base, quote] = symbol.split('/');
    if (!basesMap[base]) {
      basesMap[base] = [];
    }
    basesMap[base].push(symbol);
  }

  baseCache.set(key, basesMap);
  return basesMap;
}

export function splitSymbolsIntoQuoteAndBase(
  symbols,
  exchangeId,
  recalculate = false,
) {
  const key = exchangeId;
  const cachedValue = quoteCache.get(key);
  if (cachedValue && !recalculate) {
    return cachedValue;
  }

  const quotesMap = {};
  for (const symbol in symbols) {
    const [base, quote] = symbol.split('/');
    if (!quotesMap[quote]) {
      quotesMap[quote] = [];
    }
    quotesMap[quote].push(symbol);
  }

  quoteCache.set(key, quotesMap);
  return quotesMap;
}


File: utils/calculateTMNPrice.js
--------------------------------------------------
Content of utils/calculateTMNPrice.js:
import { CONFIG } from '../config.js';
import { splitSymbolsIntoQuoteAndBase } from './splitSymbols.js';

export function calculateTMNPrice(allPrices, USDTPrice) {
  const { customExchanges = [] } = CONFIG;
  for (const exchange in allPrices) {
    if (customExchanges.includes(exchange)) continue;

    const symbols = allPrices[exchange];

    const quotesMap = splitSymbolsIntoQuoteAndBase(symbols, exchange);
    if (quotesMap.USDT?.length) {
      for (const symbol of quotesMap['USDT']) {
        let TMNSymbol = symbol.replace('/USDT', '/TMN');
        symbols[TMNSymbol] = {};
        symbols[TMNSymbol].ask = symbols[symbol].ask * USDTPrice;
        symbols[TMNSymbol].bid = symbols[symbol].bid * USDTPrice;
      }
      if (!quotesMap.hasOwnProperty('TMN')) {
        splitSymbolsIntoQuoteAndBase(symbols, exchange, true);
      }
    }
  }
}


File: utils/storeOpenPositions.js
--------------------------------------------------
Content of utils/storeOpenPositions.js:
import { storePosition } from './database.js'; // ensure correct path

export async function storeOpenPosition({
  symbol,
  buyExchange,
  sellExchange,
  amount,
  entryBuyPrice,
  entrySellPrice,
}) {
  await storePosition({
    symbol,
    buyExchange,
    sellExchange,
    amount,
    entryBuyPrice,
    entrySellPrice,
  });
  console.log('Open position stored in DB.');
}


File: VWAP/VWAP.js
--------------------------------------------------
Content of VWAP/VWAP.js:
import { fetchOrderBooks } from '../fetch/fetchOrderBooks.js';

export async function getVWAPs(
  exchanges,
  exchangeId,
  symbols,
  tradeVolumeUSDT,
  USDTPrice,
) {
  try {
    const orderBooks = await fetchOrderBooks(exchanges, exchangeId, symbols);

    const VWAPs = calculateVWAPs(orderBooks, tradeVolumeUSDT, USDTPrice);

    return VWAPs;
  } catch (error) {
    console.error(`Error fetching VWAPs for ${exchangeId}:`, error.message);
    return {};
  }
}

// Calculate Volume Weighted Average Price (VWAP)
export function calculateVWAPs(orderBooks, tradeVolumeUSDT, USDTPrice) {
  let VWAPs = {};
  let tradeVolume = {
    USDT: tradeVolumeUSDT,
    TMN: tradeVolumeUSDT * USDTPrice,
  };
  for (let symbol in orderBooks) {
    VWAPs[symbol] = {};
    let [_, quote] = symbol.split('/');
    let orderBook = orderBooks[symbol];

    for (let side of ['asks', 'bids']) {
      let accumulatedVolume = 0;
      let accumulatedCost = 0;
      let orders = orderBook[side];
      for (const [price, amount] of orders) {
        const orderCost = price * amount;
        if (accumulatedCost + orderCost >= tradeVolume[quote]) {
          const remainingCost = tradeVolume[quote] - accumulatedCost;
          const partialAmount = remainingCost / price;
          accumulatedVolume += partialAmount;
          accumulatedCost += remainingCost;
          VWAPs[symbol][side] = accumulatedCost / accumulatedVolume;
          break;
        } else {
          accumulatedVolume += amount;
          accumulatedCost += orderCost;
        }
      }
    }
    VWAPs[symbol].spread = VWAPs[symbol]?.asks - VWAPs[symbol]?.bids;
  }
  return VWAPs;
}


File: fetch/fetchOrderBooks.js
--------------------------------------------------
Content of fetch/fetchOrderBooks.js:
import axios from 'axios';
import {
  standardizeNobitexOrderBooks,
  standardizeWallexOrderBooks,
} from '../transforms/standardizations.js';
import { splitSymbolsIntoQuoteAndBase } from '../utils/splitSymbols.js';

// Fetch Nobitex L2 Order Books
export async function fetchNobitexOrderBooks(symbols) {
  try {
    const response = await axios.get('https://api.nobitex.ir/v3/orderbook/all');
    const data = response.data;

    if (!data) {
      throw new Error('No order book data available from Nobitex');
    }

    delete data.status;

    const nobitexOrderBooks = standardizeNobitexOrderBooks(data, symbols);

    console.log('Nobitex order books fetched');
    return nobitexOrderBooks;
  } catch (error) {
    console.error('Error fetching Nobitex order books:', error);
    return {};
  }
}

// Fetch Wallex L2 Order Books
export async function fetchWallexOrderBooks(symbols) {
  try {
    const response = await axios.get('https://api.wallex.ir/v2/depth/all');
    const data = response.data.result;

    if (!data) {
      throw new Error('No order book data available from Wallex');
    }
    const wallexOrderBooks = standardizeWallexOrderBooks(data, symbols);

    console.log('Wallex order books fetched');
    return wallexOrderBooks;
  } catch (error) {
    console.error('Error fetching Wallex order books:', error.message);
    return {};
  }
}

export async function fetchOrderBooks(exchanges, exchangeId, symbols) {
  try {
    const orderBooks = {};
    const quotesMap = splitSymbolsIntoQuoteAndBase(symbols, exchangeId);
    if (exchangeId === 'nobitex') {
      const nobitexOrderBooks = await fetchNobitexOrderBooks(symbols);
      Object.assign(orderBooks, nobitexOrderBooks);
    } else if (exchangeId === 'wallex') {
      const wallexOrderBooks = await fetchWallexOrderBooks(symbols);
      Object.assign(orderBooks, wallexOrderBooks);
    } else {
      // For CCXT exchanges
      if (exchanges[exchangeId].has.fetchOrderBooks) {
        const exchangeOrderBooks = await exchanges[exchangeId].fetchOrderBooks(
          symbols,
        );
        Object.assign(orderBooks, exchangeOrderBooks);
      } else {
        const orderBooksPromises = symbols
          .filter(symbol => !quotesMap.TMN.includes(symbol))
          .map(async symbol => {
            try {
              const orderBook = await exchanges[exchangeId].fetchOrderBook(
                symbol,
              );
              orderBooks[symbol] = orderBook;
            } catch (err) {
              console.error(`Error fetching order book for ${symbol}:`, err);
            }
          });
        await Promise.allSettled(orderBooksPromises);
      }

      console.log(
        `${exchangeId.charAt(0).toUpperCase()}${exchangeId.slice(
          1,
        )} order books fetched`,
      );
    }

    return orderBooks;
  } catch (error) {
    console.error(`Error fetching VWAPs for ${exchangeId}:`, error.message);
    return {};
  }
}


File: fetch/fetchPrices.js
--------------------------------------------------
Content of fetch/fetchPrices.js:
import ccxt from 'ccxt';
import axios from 'axios';
import { CONFIG } from '../config.js';

// Function to fetch prices from Nobitex (custom implementation)
export async function fetchNobitexPrices() {
  const { coinsToConsider, coinsToIgnore } = CONFIG;
  try {
    const response = await axios.get('https://api.nobitex.ir/v3/orderbook/all');
    const data = response.data;
    delete data.status;
    const prices = {};

    for (const symbol in data) {
      let base = symbol.replace(/(IRT|USDT)$/, '');
      let quote = symbol.replace(new RegExp(`^${base}`), '');

      if (
        (coinsToConsider && !coinsToConsider.includes(base)) ||
        coinsToIgnore.includes(base)
      ) {
        continue;
      }
      // Asks and Bids are opposite to other exchanges
      const bids = data[symbol].asks;
      const asks = data[symbol].bids;

      if (bids?.length > 0 && asks?.length > 0) {
        let bidPrice = parseFloat(bids[0][0]);
        let askPrice = parseFloat(asks[0][0]);

        if (quote === 'IRT') {
          bidPrice /= 10;
          askPrice /= 10;
          quote = 'TMN';
        }

        prices[base + '/' + quote] = {
          bid: bidPrice,
          ask: askPrice,
        };
      }
    }

    console.log('Nobitex prices fetched');
    return prices;
  } catch (error) {
    console.error('Error fetching Nobitex prices:', error);
    return {};
  }
}

// Function to fetch prices from Wallex (custom implementation)
export async function fetchWallexPrices() {
  const { coinsToConsider, coinsToIgnore } = CONFIG;
  try {
    const response = await axios.get('https://api.wallex.ir/v1/markets');
    const symbols = response.data.result.symbols;

    const prices = {};

    for (const symbol in symbols) {
      const ticker = symbols[symbol];
      const base = ticker.baseAsset;
      const quote = ticker.quoteAsset;

      if (
        (coinsToConsider && !coinsToConsider.includes(base)) ||
        coinsToIgnore.includes(base)
      ) {
        continue;
      }

      const bidPrice = parseFloat(ticker.stats.bidPrice);
      const askPrice = parseFloat(ticker.stats.askPrice);

      prices[base + '/' + quote] = {
        bid: bidPrice,
        ask: askPrice,
      };
    }

    console.log('Wallex prices fetched');
    return prices;
  } catch (error) {
    console.error('Error fetching Wallex prices:', error.message);
    return {};
  }
}

// Function to fetch all prices concurrently
export async function fetchAllPrices(exchanges) {
  const { exchangesToUse } = CONFIG;
  const allPrices = {};
  const fetchPromises = exchangesToUse.map(async exchangeId => {
    if (exchangeId === 'nobitex') {
      allPrices[exchangeId] = await fetchNobitexPrices();
    } else if (exchangeId === 'wallex') {
      allPrices[exchangeId] = await fetchWallexPrices();
    } else {
      allPrices[exchangeId] = await fetchPrices(exchanges, exchangeId);
    }
  });

  await Promise.all(fetchPromises);
  return allPrices;
}

// Function to fetch prices from an exchange
export async function fetchPrices(exchanges, exchangeId) {
  const { coinsToConsider, coinsToIgnore } = CONFIG;
  try {
    const exchange = exchanges[exchangeId];
    await exchange.loadMarkets();
    const tickers = await exchange.fetchTickers();
    const prices = {};

    for (const symbol in tickers) {
      const ticker = tickers[symbol];
      const [base, quote] = symbol.split('/');

      if (
        (coinsToConsider && !coinsToConsider.includes(base)) ||
        coinsToIgnore.includes(base)
      ) {
        continue;
      }

      //! make sure to check the ticker of each exchange, because
      //! sometimes bid and ask are not available.
      prices[symbol] = {
        bid: ticker.bid || ticker.close,
        ask: ticker.ask || ticker.close,
      };
    }

    console.log(
      `${exchangeId.charAt(0).toUpperCase()}${exchangeId.slice(
        1,
      )} prices fetched`,
    );
    return prices;
  } catch (error) {
    console.error(`Error fetching prices from ${exchangeId}:`, error.message);
    return {};
  }
}


File: transforms/originalizations.js
--------------------------------------------------
Content of transforms/originalizations.js:
import { CONFIG } from '../config.js';

export function originalizeSpecialCoinOrder(exchangeId, base, amount, price) {
  const { specialCoinStandardizations } = CONFIG;

  const standardizations = specialCoinStandardizations[exchangeId];
  const standardization = standardizations.find(s => s.standardBase === base);

  if (!standardization) {
    // If no special standardization is found, return original values
    return {
      transformedBase: base,
      transformedAmount: amount,
      transformedPrice: price,
    };
  }

  const { originalBase, correctionFactor } = standardization;

  const transformedBase = originalBase;
  const transformedAmount = amount * correctionFactor;
  const transformedPrice = price / correctionFactor;

  const transformedValues = {
    transformedBase,
    transformedAmount,
    transformedPrice,
  };

  return transformedValues;
}


File: transforms/standardizations.js
--------------------------------------------------
Content of transforms/standardizations.js:
import { CONFIG } from '../config.js';
import { splitSymbolsIntoBaseAndQuote } from '../utils/splitSymbols.js';

export function standardizeNobitexOrderBooks(nobitexOrderBooks, symbols) {
  const orderBooks = {};
  for (let symbol in nobitexOrderBooks) {
    const base = symbol.replace(/(IRT|USDT)$/, '');
    let quote = symbol.replace(new RegExp(`^${base}`), '');

    const factor = quote === 'IRT' ? 10 : 1;
    if (quote === 'IRT') {
      quote = 'TMN';
    }

    const standardizedSymbol = base + '/' + quote;

    if (!symbols.includes(standardizedSymbol)) continue;

    const asks = nobitexOrderBooks[symbol].bids.map(([price, amount]) => [
      parseFloat(price) / factor,
      parseFloat(amount),
    ]);
    const bids = nobitexOrderBooks[symbol].asks.map(([price, amount]) => [
      parseFloat(price) / factor,
      parseFloat(amount),
    ]);

    orderBooks[standardizedSymbol] = {
      asks,
      bids,
    };
  }

  standardizeSpecialCoinOrderBooks('nobitex', orderBooks);
  return orderBooks;
}
export function standardizeWallexOrderBooks(wallexOrderBooks, symbols) {
  const orderBooks = {};

  for (const symbol in wallexOrderBooks) {
    const orderBook = wallexOrderBooks[symbol];

    const base = symbol.replace(/(TMN|USDT)$/, '');
    let quote = symbol.replace(new RegExp(`^${base}`), '');

    const standardizedSymbol = base + '/' + quote;

    if (!symbols.includes(standardizedSymbol)) continue;

    const asks = orderBook.ask
      .slice(0, 24)
      .map(order => [parseFloat(order.price), parseFloat(order.quantity)]);
    const bids = orderBook.bid
      .slice(0, 24)
      .map(order => [parseFloat(order.price), parseFloat(order.quantity)]);

    orderBooks[standardizedSymbol] = {
      asks,
      bids,
    };
  }

  standardizeSpecialCoinOrderBooks('wallex', orderBooks);
  return orderBooks;
}

export function standardizeSpecialCoinOrderBooks(exchangeId, orderBooks) {
  const { specialCoinStandardizations } = CONFIG;

  const standardizations = specialCoinStandardizations[exchangeId];
  const symbols = Object.keys(orderBooks);
  const basesMap = splitSymbolsIntoBaseAndQuote(symbols, exchangeId);

  for (let i = 0; i < standardizations.length; i++) {
    const { originalBase, standardBase, correctionFactor } =
      standardizations[i];

    for (const originalSymbol of basesMap[originalBase]) {
      if (!orderBooks[originalSymbol]) continue;
      const { bids, asks } = orderBooks[originalSymbol];
      const standardSymbol = originalSymbol.replace(originalBase, standardBase);

      orderBooks[standardSymbol] = {
        bids: bids.map(bid => bid * correctionFactor),
        asks: asks.map(ask => ask * correctionFactor),
      };

      delete orderBooks[originalSymbol];
    }
  }
}

export function standardizeSpecialCoinPrices(allPrices) {
  const { specialCoinStandardizations } = CONFIG;
  for (const exchangeId in specialCoinStandardizations) {
    const standardizations = specialCoinStandardizations[exchangeId];

    const symbols = Object.keys(allPrices[exchangeId]);
    const basesMap = splitSymbolsIntoBaseAndQuote(symbols, exchangeId);

    for (let i = 0; i < standardizations.length; i++) {
      const { originalBase, standardBase, correctionFactor } =
        standardizations[i];
      if (allPrices[exchangeId] && basesMap[originalBase]) {
        const priceData = allPrices[exchangeId];

        for (const originalSymbol of basesMap[originalBase]) {
          const { bid, ask } = priceData[originalSymbol];
          const standardSymbol = originalSymbol.replace(
            originalBase,
            standardBase,
          );
          allPrices[exchangeId][standardSymbol] = {
            bid: bid * correctionFactor,
            ask: ask * correctionFactor,
          };
          delete allPrices[exchangeId][originalSymbol];
        }
      }
    }
  }
}


File: monitoring/monitoring.js
--------------------------------------------------
Content of monitoring/monitoring.js:
import { CONFIG } from '../config.js';
import { getVWAPs } from '../VWAP/VWAP.js';
import { closePosition } from '../close/closePosition.js';
import { addTMNSymbols } from '../utils/addTMNSymbols.js';
import { getOpenPositions } from '../utils/database.js';

export async function monitorOpenPositions(exchanges, USDTPrice) {
  const {
    orderTypeOnClose,
    tradeVolumeUSDT,
    returnTypeOnClose,
    closeMinMarginPercent,
  } = CONFIG;

  // Fetch open positions from the database
  let openPositions = [];
  try {
    openPositions = await getOpenPositions();
  } catch (error) {
    console.error('Failed to fetch open positions from the database:', error);
    return; // Exit early if we can't get positions
  }

  if (!openPositions?.length) {
    console.log('No open positions to monitor.');
    return;
  }

  console.log('Monitoring open positions...');

  const exchangeMap = {};

  // Loop through each position
  for (const position of openPositions) {
    const { symbol, buyExchange, sellExchange } = position;

    // Add symbol to buyExchange
    if (!exchangeMap[buyExchange]) {
      exchangeMap[buyExchange] = new Set(); // Use a Set to ensure uniqueness
    }
    exchangeMap[buyExchange].add(symbol);

    // Add symbol to sellExchange
    if (!exchangeMap[sellExchange]) {
      exchangeMap[sellExchange] = new Set(); // Use a Set to ensure uniqueness
    }
    exchangeMap[sellExchange].add(symbol);
  }

  // Convert Sets back to arrays
  for (const exchange in exchangeMap) {
    exchangeMap[exchange] = Array.from(exchangeMap[exchange]);
  }
  const vwapResultsByExchange = {};
  await Promise.all(
    Object.entries(exchangeMap).map(async ([exchangeId, symbols]) => {
      const vwapResults = await getVWAPs(
        exchanges,
        exchangeId,
        symbols,
        tradeVolumeUSDT,
        USDTPrice,
      );
      vwapResultsByExchange[exchangeId] = vwapResults;
    }),
  );

  addTMNSymbols(vwapResultsByExchange, USDTPrice);

  const finalReturns = calculateFinalReturnsFromOpenPositions(
    openPositions,
    vwapResultsByExchange,
    returnTypeOnClose,
    USDTPrice,
  );

  await processPositionsConcurrently(
    finalReturns,
    exchanges,
    closeMinMarginPercent,
    orderTypeOnClose,
  );

  console.log('Finished monitoring open positions.');
}

export function calculateFinalReturnsFromOpenPositions(
  openPositions,
  vwapResultsByExchange,
  returnTypeOnClose,
  USDTPrice,
) {
  const { fees, slippage } = CONFIG;
  const finalReturns = [];
  for (const openPosition of openPositions) {
    const {
      id,
      symbol,
      buyExchange,
      sellExchange,
      entryBuyPrice,
      entrySellPrice,
    } = openPosition;

    const buyVWAP = vwapResultsByExchange[sellExchange][symbol]?.asks;
    const sellVWAP = vwapResultsByExchange[buyExchange][symbol]?.bids;

    if (!buyVWAP || !sellVWAP) continue;

    const buyFee = fees[sellExchange].taker;
    const sellFee = fees[buyExchange].taker;

    const netBuyPrice = buyVWAP * (1 + buyFee);
    const netSellPrice = sellVWAP * (1 - sellFee);

    const profitSellExhange = entrySellPrice - netBuyPrice;
    const profitBuyExhange = netSellPrice - entryBuyPrice;
    const profit = profitBuyExhange + profitSellExhange;

    const returnPercentage = (profit / entrySellPrice + entryBuyPrice) * 100;

    // Calculate slippage-adjusted prices
    const netSellPriceWithSlippage = netSellPrice * (1 - slippage);
    const netBuyPriceWithSlippage = netBuyPrice * (1 + slippage);

    // Profit with slippage
    const profitSellExchangeWithSlippage =
      entrySellPrice - netBuyPriceWithSlippage;
    const profitBuyExchangeWithSlippage =
      netSellPriceWithSlippage - entryBuyPrice;
    const profitWithSlippage =
      profitSellExchangeWithSlippage + profitBuyExchangeWithSlippage;

    const returnPercentageWithSlippage =
      profitWithSlippage / (entrySellPrice + entryBuyPrice);

    let selectedBuyPrice;
    let selectedSellPrice;
    switch (returnTypeOnClose) {
      case 'slip':
        selectedBuyPrice = netBuyPriceWithSlippage;
        selectedSellPrice = netSellPriceWithSlippage;
        break;

      default:
        selectedBuyPrice = netBuyPrice;
        selectedSellPrice = netSellPrice;
        break;
    }

    const selectedReturnPercentage =
      ((selectedSellPrice - selectedBuyPrice) /
        (selectedSellPrice + selectedBuyPrice)) *
      100;

    finalReturns.push({
      openPosition,
      id: openPosition?.id,
      symbol,
      buyExchange,
      sellExchange,
      selectedBuyPrice,
      selectedSellPrice,
      selectedReturnPercentage,
      netBuyPrice,
      netSellPrice,
      returnPercentage,
      netBuyPriceWithSlippage,
      netSellPriceWithSlippage,
      returnPercentageWithSlippage,
      tradeVolumeUSDT,
      USDTPrice,
    });
  }
}

const processPositionsConcurrently = async (
  finalReturns,
  exchanges,
  closeMinMarginPercent,
  orderTypeOnClose,
) => {
  // Map finalReturns to an array of promises
  const promises = finalReturns.map(async finalReturn => {
    const {
      id,
      symbol,
      buyExchange,
      sellExchange,
      amount,
      entryBuyPrice,
      entrySellPrice,
      selectedReturnPercentage, // Added for margin check
    } = finalReturn;

    const position = {
      id,
      symbol,
      buyExchange,
      sellExchange,
      amount,
      entryBuyPrice,
      entrySellPrice,
    };

    try {
      console.log(
        `Position ${symbol} on ${buyExchange}/${sellExchange}: Current Return: ${selectedReturnPercentage.toFixed(
          2,
        )}%`,
      );

      // Skip if exit condition is not met
      if (selectedReturnPercentage < closeMinMarginPercent) {
        console.log(`Exit condition not met for ${symbol}. Skipping...`);
        return; // Skip further processing for this position
      }

      console.log(
        `Exit condition met for ${symbol} on ${buyExchange}/${sellExchange}. Closing position...`,
      );

      // Close the position
      await closePosition(exchanges, position, orderTypeOnClose);
    } catch (error) {
      console.error(
        `Error monitoring position ${symbol} on ${buyExchange}/${sellExchange}:`,
        error.message,
      );
    }
  });

  // Execute all promises concurrently and wait for completion
  const results = await Promise.allSettled(promises);

  // Log the results
  results.forEach((result, index) => {
    if (result.status === 'fulfilled') {
      console.log(
        `Successfully processed position ${finalReturns[index].symbol}`,
      );
    } else {
      console.error(
        `Failed to process position ${finalReturns[index].symbol}:`,
        result.reason,
      );
    }
  });
};


